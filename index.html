<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å•è¯æ‹¼å†™é—¯å…³æ¸¸æˆV4</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6', // ä¸»è‰²è°ƒï¼šè“è‰²
            secondary: '#10B981', // è¾…åŠ©è‰²ï¼šç»¿è‰²
            accent: '#F59E0B', // å¼ºè°ƒè‰²ï¼šæ©™è‰²
            danger: '#EF4444', // é”™è¯¯è‰²ï¼šçº¢è‰²
            neutral: '#6B7280', // ä¸­æ€§è‰²ï¼šç°è‰²
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
          animation: {
            'pop': 'pop 0.3s ease',
            'streak': 'streak 1s forwards',
            'fade-in': 'fadeIn 0.5s ease',
            'slide-up': 'slideUp 0.5s ease-out',
            'highlight': 'highlight 1s ease',
          },
          keyframes: {
            pop: {
              '0%, 100%': { transform: 'scale(1)' },
              '50%': { transform: 'scale(1.1)' },
            },
            streak: {
              '0%': { opacity: '0', transform: 'translate(-50%, -20px)' },
              '50%': { opacity: '1', transform: 'translate(-50%, 0)' },
              '100%': { opacity: '0', transform: 'translate(-50%, 20px)' },
            },
            fadeIn: {
              '0%': { opacity: '0' },
              '100%': { opacity: '1' },
            },
            slideUp: {
              '0%': { transform: 'translateY(20px)', opacity: '0' },
              '100%': { transform: 'translateY(0)', opacity: '1' },
            },
            highlight: {
              '0%, 100%': { background: '#EF4444' },
              '50%': { background: '#f87171' },
            }
          },
        },
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .word-input {
        @apply w-12 h-12 sm:w-10 sm:h-10 rounded-md border-2 border-gray-300 text-center text-xl font-medium transition-all duration-300;
        text-transform: lowercase; /* å¼ºåˆ¶æ˜¾ç¤ºå°å†™ */
      }
      .word-input::placeholder {
        text-transform: none; /* ç¡®ä¿å ä½ç¬¦ä¸å—å½±å“ */
      }
      .word-input:focus {
        @apply border-primary ring-2 ring-primary/30;
      }
      .word-input.correct {
        @apply border-secondary bg-green-50 animate-pop;
      }
      .word-input.wrong {
        @apply border-danger bg-red-50;
      }
      .fixed-letter {
        @apply w-12 h-12 sm:w-10 sm:h-10 rounded-md border-2 border-gray-300 bg-gray-100 text-gray-600 text-center text-xl font-medium flex items-center justify-center cursor-not-allowed;
      }
      .game-btn {
        @apply px-4 py-3 sm:px-5 sm:py-2.5 rounded-lg font-medium transition-all duration-300 hover:translate-y-[-2px] hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2;
      }
      .streak-effect {
        @apply fixed top-1/4 left-1/2 transform -translate-x-1/2 text-4xl font-bold text-accent opacity-0 pointer-events-none animate-streak;
      }
      .progress-bar {
        @apply h-2 rounded-full overflow-hidden bg-gray-200;
      }
      .progress-fill {
        @apply h-full transition-all duration-500 ease-out;
      }
      .level-badge {
        @apply inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-800;
      }
      .reward-card {
        @apply bg-gradient-to-br from-yellow-100 to-orange-100 rounded-xl p-4 border border-yellow-200 shadow-lg transition-all duration-500 animate-fade-in;
      }
      .listening {
        background-color: #ef4444 !important;
      }
      #similarityMeter {
        transition: all 0.3s ease;
      }
      .word-input.highlight {
        animation: highlight 1s ease;
      }
      /* ç§»åŠ¨ç«¯æŒ‰é’®å¸ƒå±€ä¼˜åŒ– */
      .btn-group {
        @apply grid grid-cols-2 gap-2 sm:flex sm:gap-2;
      }
      .btn-group .game-btn {
        @apply flex-1 justify-center;
      }
    }
  </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-50 min-h-screen font-sans">
  <div class="max-w-3xl mx-auto px-4 py-6 sm:py-8">
    <!-- æ¸¸æˆæ ‡é¢˜ -->
    <div class="text-center mb-6 sm:mb-8 animate-fade-in">
      <h1 class="text-[clamp(1.8rem,5vw,3rem)] font-bold text-gray-800 mb-2">
        <i class="fa fa-book text-primary mr-2"></i>å•è¯æ‹¼å†™é—¯å…³æ¸¸æˆ
      </h1>
      <p class="text-gray-600 text-base sm:text-lg">æå‡ä½ çš„è‹±è¯­è¯æ±‡é‡ï¼ŒæŒ‘æˆ˜è‡ªæˆ‘ï¼</p>
    </div>

    <!-- æ¸¸æˆä¸»å®¹å™¨ -->
    <div class="bg-white rounded-xl p-5 sm:p-6 shadow-lg mb-6 animate-fade-in">
      <!-- æ–‡ä»¶é€‰æ‹©åŒºåŸŸ -->
      <div class="mb-5 pb-4 border-b border-gray-100">
        <div class="flex flex-col sm:flex-row sm:items-center justify-between gap-3">
          <div class="w-full sm:w-auto">
            <label class="block text-sm font-medium text-gray-700 mb-1">é€‰æ‹©å•è¯æ–‡ä»¶ï¼š</label>
            <select id="wordFileSelect" class="w-full sm:w-auto px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition-all">
              <option value="default">é»˜è®¤å•è¯åº“</option>
              <option value="two">äºŒå¹´çº§å•è¯</option>
              <option value="basic">æ–°æ¦‚å¿µ1è¯åº“</option>
            </select>
          </div>
          <div class="flex gap-2 w-full sm:w-auto">
            <button onclick="deleteCurrentFile()" id="deleteFileBtn" class="game-btn bg-red-500 text-white focus:ring-red-500 flex-1 sm:flex-none">
              <i class="fa fa-trash-o mr-1"></i> åˆ é™¤è¿›åº¦
            </button>
            <button onclick="resetProgress()" class="game-btn bg-gray-200 text-gray-700 focus:ring-gray-400 flex-1 sm:flex-none">
              <i class="fa fa-refresh mr-1"></i> é‡ç½®è¿›åº¦
            </button>
          </div>
        </div>
        <div id="fileNotification" class="mt-2 text-sm text-gray-600"></div>
      </div>

      <!-- æ¸¸æˆå†…å®¹åŒºåŸŸ -->
      <div id="content" class="space-y-5">
        <!-- å…³å¡å’Œé¢˜ç›®ä¿¡æ¯ -->
        <div class="animate-slide-up">
          <div id="instruction" class="text-lg font-semibold text-gray-800 mb-1"></div>
          <div id="stats" class="flex flex-wrap gap-2 text-sm text-gray-600"></div>
        </div>

        <!-- å•è¯ä¿¡æ¯ -->
        <div class="bg-blue-50 rounded-lg p-4 mb-5 animate-slide-up" style="animation-delay: 0.1s">
          <div id="question" class="text-base font-medium text-gray-800 mb-2"></div>
          <div id="definition" class="text-lg text-primary font-medium mb-1"></div>
          <div id="phonetic" class="text-base text-indigo-500 italic"></div>
        </div>

        <!-- å•è¯è¾“å…¥åŒºåŸŸ -->
        <div class="flex justify-center mb-5 animate-slide-up" style="animation-delay: 0.2s">
          <div id="letterBox" class="flex gap-2 flex-wrap justify-center"></div>
        </div>

        <!-- æ“ä½œæŒ‰é’® - ç§»åŠ¨ç«¯ä¼˜åŒ–å¸ƒå±€ -->
        <div class="mb-5 animate-slide-up" style="animation-delay: 0.3s">
          <div class="btn-group mb-2">
            <button onclick="prevQuestion()" id="prevBtn" class="game-btn bg-gray-200 text-gray-700 focus:ring-gray-400">
              <i class="fa fa-arrow-left mr-1"></i> ä¸Šä¸€é¢˜
            </button>
            <button onclick="toggleListening()" id="startReadingBtn" class="game-btn bg-orange-500 text-white focus:ring-orange-500">
              <i class="fa fa-microphone mr-1"></i> å¼€å§‹æœ—è¯»
            </button>
          </div>
          <div class="btn-group">
            <button onclick="readWord()" class="game-btn bg-primary text-white focus:ring-primary">
              <i class="fa fa-volume-up mr-1"></i> å¬å•è¯
            </button>
            <button onclick="showMistakes()" class="game-btn bg-green-500 text-white focus:ring-green-500">
              <i class="fa fa-book mr-1"></i> æŸ¥çœ‹é”™é¢˜æœ¬
            </button>
          </div>
          <div class="btn-group mt-2">
            <button onclick="submitAnswer()" id="nextBtn" class="game-btn bg-gray-200 text-gray-700 focus:ring-gray-400">
              è·³è¿‡æ­¤é¢˜ <i class="fa fa-arrow-right ml-1"></i>
            </button>
            <button onclick="exitReview()" class="game-btn bg-green-500 text-white focus:ring-green-500" style="display:none">
              <i class="fa fa-arrow-left mr-1"></i> è¿”å›é—¯å…³
            </button>
            <button onclick="nextQuestion()" id="continueBtn" class="game-btn bg-secondary text-white focus:ring-secondary" style="display:none">
              <i class="fa fa-arrow-right mr-1"></i> ç»§ç»­ä¸‹ä¸€é¢˜
            </button>
          </div>
        </div>

        <!-- ç›¸ä¼¼åº¦æŒ‡ç¤ºå™¨ -->
        <div id="similarityMeter" class="progress-bar mb-5 animate-slide-up" style="animation-delay: 0.4s; display: none">
          <div class="progress-fill bg-primary" id="similarityFill"></div>
        </div>

        <!-- é€‰é¡¹åŒºåŸŸ -->
        <div id="options" class="space-y-2 animate-slide-up" style="animation-delay: 0.5s"></div>

        <!-- ç»“æœåŒºåŸŸ -->
        <div id="result" class="mt-4 p-4 rounded-lg text-center font-medium animate-slide-up" style="animation-delay: 0.6s"></div>

        <!-- è¿ç»­æ­£ç¡®å¥–åŠ±åŒºåŸŸ -->
        <div id="streakReward" class="hidden reward-card mt-5">
          <h3 class="font-bold text-lg text-orange-600 mb-2">è¿ç»­æ­£ç¡®å¥–åŠ±!</h3>
          <p id="rewardMessage" class="text-gray-700 mb-3"></p>
          <div class="flex justify-center">
            <button onclick="claimReward()" class="game-btn bg-orange-500 text-white focus:ring-orange-500">
              <i class="fa fa-gift mr-1"></i> é¢†å–å¥–åŠ±
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨ä¿¡æ¯ -->
    <div class="text-center text-gray-500 text-sm mt-6 animate-fade-in">
      <p>å•è¯æ‹¼å†™é—¯å…³æ¸¸æˆ V4 Â© 2025 | æå‡ä½ çš„è‹±è¯­è¯æ±‡é‡</p>
    </div>
  </div>

  <!-- éŸ³é¢‘å…ƒç´  -->
  <audio id="bgm" autoplay loop>
    <source src="https://cdn.pixabay.com/audio/2022/10/30/audio_46fdd201cc.mp3" type="audio/mpeg">
  </audio>
  <audio id="correct-sound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_e0b6f67a53.mp3"></audio>
  <audio id="wrong-sound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_2307f9b816.mp3"></audio>
  <audio id="reward-sound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_139c839a53.mp3"></audio>

  <!-- è¿ç»­æ­£ç¡®æç¤º -->
  <div id="streakEffect" class="streak-effect"></div>

  <script>
    // æ ¸å¿ƒå•è¯åº“
    const defaultWordList = [
      {word:"morning", definition:"æ—©æ™¨ï¼›ä¸Šåˆ", phonetic:"/ËˆmÉ”ËnÉªÅ‹/"},
      {word:"afternoon", definition:"åˆåï¼›ä¸‹åˆ", phonetic:"/ËŒÉ‘ËftÉ™ËˆnuËn/"},
      {word:"evening", definition:"æ™šä¸Šï¼›å‚æ™š", phonetic:"/ËˆiËvnÉªÅ‹/"},
      {word:"night", definition:"å¤œé—´ï¼›å¤œæ™š", phonetic:"/naÉªt/"},
      {word:"fine", definition:"å¥½çš„", phonetic:"/faÉªn/"},
      {word:"thank", definition:"æ„Ÿè°¢", phonetic:"/Î¸Ã¦Å‹k/"},
      {word:"goodbye", definition:"å†è§", phonetic:"/ËŒÉ¡ÊŠdËˆbaÉª/"},
      {word:"woof", definition:"ç‹—å«å£°", phonetic:"/wÊŠf/"},
      {word:"Mrs", definition:"å¤«äººï¼›å¤ªå¤ª", phonetic:"/ËˆmÉªsÉªz/"},
      {word:"day", definition:"ä¸€å¤©", phonetic:"/deÉª/"},
      {word:"today", definition:"ä»Šå¤©", phonetic:"/tÉ™ËˆdeÉª/"},
    ];

    // å…³å¡è°œé¢˜
    const puzzleQuestions = [
      { question: "â€œæ—¥å‡ºå¤§ç±³â€çŒœä¸€ä¸ªå­—ï¼Ÿ", options: ["æ˜", "æ˜Œ", "æ—©", "äº®"], answer: "æ˜Œ" },
      { question: "ä»€ä¹ˆä¸œè¥¿è¶Šæ´—è¶Šè„ï¼Ÿ", options: ["è¡£æœ", "æ‰‹", "æ°´", "åœ°æ¿"], answer: "æ°´" },
      { question: "å“ªç§ç‹—ä¸ä¼šå«ï¼Ÿ", options: ["çƒ­ç‹—", "è—ç’", "å“ˆå£«å¥‡", "ç‰§ç¾ŠçŠ¬"], answer: "çƒ­ç‹—" },
    ];

    // å‘éŸ³å˜ä½“ï¼ˆç”¨äºå®¹é”™ï¼‰
    const pronunciationVariants = {
      "morning": ["mornin", "mornning"],
      "afternoon": ["afternun", "afternooon"],
      "evening": ["evenin", "evenning"],
    };

    // è¿ç»­æ­£ç¡®å¥–åŠ±é…ç½®
    const streakRewards = {
      3: {
        description: "è·å¾—é¢å¤–æ˜Ÿæ˜Ÿï¼",
        action: () => {
          levelStars[level] = Math.min((levelStars[level] || 0) + 1, 3);
          return `å½“å‰å…³å¡æ˜Ÿæ˜Ÿï¼š${levelStars[level]}/3 â­`;
        }
      },
      5: {
        description: "è·³è¿‡ä¸€ä¸ªå•è¯",
        action: () => {
          currentIndex++;
          return "å·²è‡ªåŠ¨è·³è¿‡ä¸‹ä¸€ä¸ªå•è¯ï¼";
        }
      }
    };

    // æ¸¸æˆæ ¸å¿ƒå˜é‡
    let wordFiles = { 
      "default": { name: "é»˜è®¤å•è¯åº“", words: defaultWordList, isCustom: false, loaded: true },
      "two": { name: "äºŒå¹´çº§å•è¯", words: [], isCustom: true, loaded: false },
      "basic": { name: "æ–°æ¦‚å¿µ1è¯åº“", words: [], isCustom: true, loaded: false }
    };
    let currentFile = "default";
    let gameData = JSON.parse(localStorage.getItem('wordGameData')) || {
      currentIndex: 0, level: 0, correctCount: 0, wrongList: [], levelStars: [], puzzleQuestionsUsed: []
    };

    // å†…å­˜å˜é‡
    let { currentIndex, level, correctCount, wrongList, levelStars } = gameData;
    let inPuzzle = false;
    let isReviewMode = false;
    let currentStreak = 0;
    let currentReviewIndex = 0;
    let levelCorrect = 0;
    let recognition;
    let isListening = false;
    let showFullFirstLetter = false;
    let answerCorrect = false; // æ ‡è®°ç­”æ¡ˆæ˜¯å¦æ­£ç¡®
    let speechSynthAvailable = false; // è¯­éŸ³åˆæˆå¯ç”¨çŠ¶æ€

    // DOMå…ƒç´ 
    const [instructionEl, questionEl, resultEl, optionsEl, definitionEl, phoneticEl, letterBox, statsEl] = 
      ["instruction", "question", "result", "options", "definition", "phonetic", "letterBox", "stats"].map(id => document.getElementById(id));
    const [nextBtn, prevBtn, startReadingBtn, deleteFileBtn, fileNotification, similarityMeter, similarityFill, streakReward, rewardMessage] =
      ["nextBtn", "prevBtn", "startReadingBtn", "deleteFileBtn", "fileNotification", "similarityMeter", "similarityFill", "streakReward", "rewardMessage"].map(id => document.getElementById(id));
    const [correctSound, wrongSound, rewardSound] = 
      ["correct-sound", "wrong-sound", "reward-sound"].map(id => document.getElementById(id));
    const readWordBtn = document.querySelector('button[onclick="readWord()"]');

    // åˆå§‹åŒ–
    function init() {
      document.getElementById("wordFileSelect").addEventListener('change', loadSelectedWordFile);
      loadFileProgress();
      updateDeleteButton();
      loadNext();
      initSpeechRecognition();
      checkSpeechSynthesis();
    }

    // æ£€æŸ¥è¯­éŸ³åˆæˆæ”¯æŒ
    function checkSpeechSynthesis() {
      if ('speechSynthesis' in window) {
        speechSynthAvailable = true;
        readWordBtn.disabled = false;
        readWordBtn.title = "";
      } else {
        speechSynthAvailable = false;
        readWordBtn.disabled = true;
        readWordBtn.title = "æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆ";
      }
    }

    // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
    function updateDeleteButton() {
      const isCustom = wordFiles[currentFile]?.isCustom;
      deleteFileBtn.disabled = !isCustom;
      deleteFileBtn.title = isCustom ? "" : "é»˜è®¤å•è¯åº“ä¸èƒ½åˆ é™¤";
    }

    // åŠ è½½å•è¯æ–‡ä»¶
    function loadSelectedWordFile() {
      const selectedFile = document.getElementById("wordFileSelect").value;
      if (selectedFile === currentFile) return;
      
      saveCurrentFileProgress();
      currentFile = selectedFile;
      fileNotification.textContent = "";
      updateDeleteButton();
      
      const file = wordFiles[currentFile];
      if (!file.loaded) {
        fileNotification.textContent = `æ­£åœ¨åŠ è½½ ${file.name}...`;
        
        // è¯åº“æ–‡ä»¶è·¯å¾„
        const fileName = {
          "two": "two_words.txt",
          "basic": "basic_words.txt"
        }[currentFile];

        // è¯»å–å¹¶è§£æé€—å·åˆ†éš”çš„TXTæ–‡ä»¶
        fetch(fileName)
          .then(response => {
            if (!response.ok) throw new Error("æ–‡ä»¶ä¸å­˜åœ¨æˆ–åŠ è½½å¤±è´¥");
            return response.text();
          })
          .then(text => {
            const words = [];
            // æŒ‰è¡Œåˆ†å‰²ï¼Œè¿‡æ»¤ç©ºè¡Œå’Œæ— æ•ˆè¡Œ
            const lines = text.split('\n')
              .map(line => line.trim())
              .filter(line => line);

            lines.forEach((line, index) => {
              // æŒ‰è‹±æ–‡é€—å·åˆ†å‰²
              const parts = line.split(',');
              
              // æ ¡éªŒæ ¼å¼ï¼ˆè‡³å°‘åŒ…å«å•è¯å’Œé‡Šä¹‰ï¼‰
              if (parts.length < 2) {
                console.warn(`ç¬¬${index+1}è¡Œæ ¼å¼é”™è¯¯ï¼ˆéœ€é€—å·åˆ†éš”ï¼‰ï¼Œè·³è¿‡ï¼š${line}`);
                return;
              }
              
              // æå–å­—æ®µ
              words.push({
                word: parts[0].trim(),
                definition: parts[1].trim(),
                phonetic: parts[2]?.trim() || 'æ— '
              });
            });

            if (words.length === 0) {
              throw new Error("æœªè§£æåˆ°æœ‰æ•ˆå•è¯ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼");
            }

            // åŠ è½½æˆåŠŸï¼Œæ›´æ–°æ¸¸æˆæ•°æ®
            file.words = words;
            file.loaded = true;
            fileNotification.textContent = `åŠ è½½æˆåŠŸï¼å…± ${words.length} ä¸ªå•è¯`;
            loadFileProgress();
            loadNext();
          })
          .catch(error => {
            fileNotification.textContent = `åŠ è½½å¤±è´¥ï¼š${error.message}`;
            console.error("è¯åº“åŠ è½½é”™è¯¯ï¼š", error);
          });
        return;
      }
      
      loadFileProgress();
      loadNext();
    }

    // è¿›åº¦å­˜å‚¨ä¸åŠ è½½
    function saveCurrentFileProgress() {
      const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
      progressData[currentFile] = {
        currentIndex, level, correctCount, wrongList, levelStars
      };
      localStorage.setItem('wordFileProgress', JSON.stringify(progressData));
    }

    function loadFileProgress() {
      const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
      const fileProgress = progressData[currentFile] || {};
      currentIndex = fileProgress.currentIndex || 0;
      level = fileProgress.level || 0;
      correctCount = fileProgress.correctCount || 0;
      wrongList = fileProgress.wrongList || [];
      levelStars = fileProgress.levelStars || [];
    }

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    function updateStats() {
      const currentWords = wordFiles[currentFile].words;
      statsEl.innerHTML = `
        <div><i class="fa fa-check-circle text-green-500 mr-1"></i> æ­£ç¡®ï¼š<b>${correctCount}</b></div>
        <div><i class="fa fa-times-circle text-red-500 mr-1"></i> é”™è¯¯ï¼š<b>${wrongList.length}</b></div>
        <div><i class="fa fa-book text-primary mr-1"></i> è¿›åº¦ï¼š<b>${currentIndex + 1}/${currentWords.length}</b></div>
      `;
    }

    // åŠ è½½ä¸‹ä¸€é¢˜
    function loadNext() {
      // æ–°å¢ï¼šæ¸…é™¤è°œé¢˜é—®é¢˜
      questionEl.textContent = "";
      // é‡ç½®UIçŠ¶æ€
      resultEl.textContent = "";
      optionsEl.innerHTML = "";
      letterBox.innerHTML = "";
      similarityMeter.style.display = "none";
      streakReward.classList.add("hidden");
      nextBtn.style.display = "inline-block";
      continueBtn.style.display = "none";
      answerCorrect = false;
      updateStats();

      // æŒ‰é’®çŠ¶æ€æ›´æ–°
      nextBtn.textContent = isReviewMode ? "ä¸‹ä¸€ä¸ªé”™é¢˜" : "è·³è¿‡æ­¤é¢˜";
      prevBtn.disabled = isReviewMode ? currentReviewIndex <= 0 : currentIndex <= 0;

      // é”™é¢˜å›é¡¾æ¨¡å¼
      if (isReviewMode) {
        document.querySelector('button[onclick="exitReview()"]').style.display = "inline-block";
        if (wrongList.length === 0) {
          instructionEl.textContent = "ğŸ‰ æ­å–œä½ æ”»å…‹äº†æ‰€æœ‰é”™é¢˜ï¼";
          definitionEl.textContent = "ç»§ç»­åŠ æ²¹å“¦ï¼";
          phoneticEl.textContent = "";
          nextBtn.style.display = "none";
          prevBtn.style.display = "none";
          return;
        }
        currentReviewIndex = Math.min(currentReviewIndex, wrongList.length - 1);
        const wordObj = wrongList[currentReviewIndex];
        instructionEl.innerHTML = `<span class="level-badge">é”™é¢˜å›é¡¾</span> ç¬¬ ${currentReviewIndex + 1}/${wrongList.length} é¢˜`;
        definitionEl.textContent = `ä¸­æ–‡æç¤ºï¼š${wordObj.definition}`;
        phoneticEl.textContent = `éŸ³æ ‡ï¼š${wordObj.phonetic || 'æ— '}`;
        generateInputBoxes(wordObj);
        return;
      }

      // æ­£å¸¸é—¯å…³æ¨¡å¼
      document.querySelector('button[onclick="exitReview()"]').style.display = "none";
      const start = level * 5;
      const currentWords = wordFiles[currentFile].words;
      
      // å…³å¡å®Œæˆï¼Œæ˜¾ç¤ºè°œé¢˜
      if (currentIndex - start >= 5 && !inPuzzle) {
        showPuzzle();
        return;
      }
      
      // å…¨éƒ¨å®Œæˆ
      if (currentIndex >= currentWords.length) {
        instructionEl.textContent = "ğŸ‰ æ­å–œä½ å®Œæˆæ‰€æœ‰å•è¯ï¼";
        definitionEl.innerHTML = `æ€»æ˜Ÿçº§ï¼š${levelStars.reduce((a, b) => a + b, 0)}/${levelStars.length * 3} â­`;
        phoneticEl.textContent = "";
        nextBtn.style.display = "none";
        prevBtn.style.display = "none";
        return;
      }

      // æ˜¾ç¤ºå½“å‰å•è¯
      const wordObj = currentWords[currentIndex];
      instructionEl.innerHTML = `<span class="level-badge">ç¬¬ ${level + 1} å…³</span> ç¬¬ ${currentIndex - start + 1}/5 é¢˜`;
      definitionEl.textContent = `ä¸­æ–‡æç¤ºï¼š${wordObj.definition}`;
      phoneticEl.textContent = `éŸ³æ ‡ï¼š${wordObj.phonetic || 'æ— '}`;
      generateInputBoxes(wordObj);
	  
	  // æ–°å¢ï¼šè‡ªåŠ¨æœ—è¯»å•è¯
	  if (speechSynthAvailable) {
		readWord();
	  }
    }

    // ç”Ÿæˆè¾“å…¥æ¡† - å·²ä¿®æ”¹ï¼šå»é™¤é¦–å­—æ¯å›ºå®šæ˜¾ç¤º
    function generateInputBoxes(wordObj) {
      // ç”Ÿæˆæ‰€æœ‰å­—æ¯çš„è¾“å…¥æ¡†ï¼ˆåŒ…æ‹¬é¦–å­—æ¯ï¼‰
      for (let i = 0; i < wordObj.word.length; i++) {
        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 1;
        input.className = "word-input";
        input.dataset.index = i;
        // ç¡®ä¿è¾“å…¥è½¬æ¢ä¸ºå°å†™
        input.addEventListener('input', function() {
          if (this.value) {
            this.value = this.value.toLowerCase();
          }
        });
        addInputListeners(input);
        letterBox.appendChild(input);
      }
      letterBox.querySelector("input")?.focus();
    }

    // è¾“å…¥æ¡†äº‹ä»¶ç›‘å¬
    function addInputListeners(input) {
      // è¾“å…¥åè‡ªåŠ¨è·³åˆ°ä¸‹ä¸€ä¸ª
      input.addEventListener('input', function() {
        if (this.value) {
          const next = this.nextElementSibling;
          if (next?.tagName === "INPUT") {
            next.focus();
          } else {
            checkAnswer(); // æœ€åä¸€ä¸ªè¾“å…¥æ¡†å¡«æ»¡åè‡ªåŠ¨æ£€æŸ¥
          }
        }
      });

      // é€€æ ¼é”®å¤„ç†
      input.addEventListener('keydown', function(e) {
        if (e.key === 'Backspace' && !this.value) {
          const prev = this.previousElementSibling;
          if (prev?.tagName === "INPUT") {
            prev.focus();
          }
        }
      });
    }

    // æ£€æŸ¥ç­”æ¡ˆ
    function checkAnswer() {
      const currentWords = wordFiles[currentFile].words;
      const currentWord = isReviewMode 
        ? wrongList[currentReviewIndex] 
        : currentWords[currentIndex];
      
      // è·å–ç”¨æˆ·è¾“å…¥ï¼ˆç¡®ä¿å…¨éƒ¨è½¬ä¸ºå°å†™ï¼‰
      const inputs = letterBox.querySelectorAll("input");
      let userAnswer = "";
      inputs.forEach(input => userAnswer += (input.value || '').toLowerCase());

      // æ£€æŸ¥æ˜¯å¦å¡«æ»¡
      if (userAnswer.length !== currentWord.word.length) return;

      // ç›¸ä¼¼åº¦è®¡ç®—
      similarityMeter.style.display = "block";
      const similarity = calculateSimilarity(userAnswer, currentWord.word.toLowerCase());
      similarityFill.style.width = `${similarity * 100}%`;

      // åˆ¤æ–­å¯¹é”™
      const isCorrect = userAnswer === currentWord.word.toLowerCase() || 
        (pronunciationVariants[currentWord.word]?.includes(userAnswer) ?? false);

      // æ ‡è®°è¾“å…¥æ¡†çŠ¶æ€
      inputs.forEach((input, i) => {
        const correctChar = currentWord.word[i].toLowerCase();
        input.className = `word-input ${input.value.toLowerCase() === correctChar ? 'correct' : 'wrong'}`;
      });

      // å¤„ç†ç»“æœ
      if (isCorrect) {
        resultEl.className = "mt-4 p-4 rounded-lg bg-green-100 text-green-800";
        resultEl.textContent = `ğŸ‰ æ­£ç¡®ï¼å•è¯ï¼š${currentWord.word}`;
        correctSound.play();
        answerCorrect = true;
        continueBtn.style.display = "inline-block";
        nextBtn.style.display = "none";
        
        // æç¤ºç”¨æˆ·æœ—è¯»å•è¯
        setTimeout(() => {
          resultEl.textContent += " è¯·æœ—è¯»å•è¯ä»¥ç»§ç»­ä¸‹ä¸€é¢˜";
          startReadingBtn.focus();
        }, 500);
      } else {
        resultEl.className = "mt-4 p-4 rounded-lg bg-red-100 text-red-800";
        resultEl.textContent = `âŒ é”™è¯¯ï¼æ­£ç¡®å•è¯ï¼š${currentWord.word}`;
        wrongSound.play();
        currentStreak = 0;
        
        // æ·»åŠ åˆ°é”™é¢˜æœ¬
        if (!wrongList.some(w => w.word === currentWord.word)) {
          wrongList.push(currentWord);
        }

        // é«˜äº®é”™è¯¯å­—æ¯1ç§’åæ¸…ç©º
        setTimeout(() => {
          const inputs = letterBox.querySelectorAll("input");
          inputs.forEach((input, i) => {
            const correctChar = currentWord.word[i].toLowerCase();
            if (input.value.toLowerCase() !== correctChar) {
              input.classList.add('highlight');
            }
          });
          
          // 1ç§’åæ¸…ç©ºè¾“å…¥æ¡†
          setTimeout(() => {
            inputs.forEach(input => {
              input.value = '';
              input.className = 'word-input';
              input.classList.remove('highlight');
            });
            letterBox.querySelector("input")?.focus();
          }, 1000);
        }, 500);
      }

      saveProgress();
    }

    // æ˜¾ç¤ºè¿ç»­æ­£ç¡®æ•ˆæœ
    function showStreakEffect() {
      const streakEl = document.getElementById("streakEffect");
      streakEl.textContent = `+${currentStreak} è¿å‡»ï¼`;
      streakEl.style.display = "block";
      setTimeout(() => {
        streakEl.style.display = "none";
      }, 1000);
    }

    // ä¸‹ä¸€é¢˜å¤„ç†
    function nextQuestion() {
      if (isReviewMode) {
        currentReviewIndex++;
      } else {
        // åªæœ‰ç­”æ¡ˆæ­£ç¡®ä¸”å·²æœ—è¯»æ‰èƒ½ç»§ç»­
        if (!answerCorrect) return;
        
        correctCount++;
        currentStreak++;
        levelCorrect++;
        
        // æ£€æŸ¥è¿ç»­æ­£ç¡®å¥–åŠ±
        if (streakRewards[currentStreak]) {
          showReward(currentStreak);
          return;
        }
        
        currentIndex++;
      }
      loadNext();
    }

    // ä¸Šä¸€é¢˜
    function prevQuestion() {
      if (isReviewMode) {
        if (currentReviewIndex > 0) currentReviewIndex--;
      } else if (currentIndex > 0) {
        currentIndex--;
        // è°ƒæ•´è®¡æ•°
        const currentWord = wordFiles[currentFile].words[currentIndex];
        if (!wrongList.some(w => w.word === currentWord.word)) {
          correctCount--;
          if (currentStreak > 0) currentStreak--;
        }
      }
      loadNext();
    }

    // è·³è¿‡å½“å‰é¢˜
    function submitAnswer() {
      if (isReviewMode) {
        currentReviewIndex++;
        loadNext();
        return;
      }

      if (inPuzzle) {
        // è°œé¢˜è·³è¿‡ï¼Œè¿›å…¥ä¸‹ä¸€å…³
        level++;
        levelCorrect = 0;
        currentIndex = level * 5;
        inPuzzle = false;
        loadNext();
        return;
      }

      // æ­£å¸¸é¢˜è·³è¿‡ï¼ˆåŠ å…¥é”™é¢˜ï¼‰
      const currentWord = wordFiles[currentFile].words[currentIndex];
      if (!wrongList.some(w => w.word === currentWord.word)) {
        wrongList.push(currentWord);
      }
      currentStreak = 0;
      currentIndex++;
      saveProgress();
      loadNext();
    }

    // æ˜¾ç¤ºè°œé¢˜
    function showPuzzle() {
      inPuzzle = true;
      // é€‰æ‹©æœªä½¿ç”¨çš„è°œé¢˜
      let availablePuzzles = puzzleQuestions.filter(q => !gameData.puzzleQuestionsUsed.includes(puzzleQuestions.indexOf(q)));
      if (availablePuzzles.length === 0) {
        availablePuzzles = puzzleQuestions;
        gameData.puzzleQuestionsUsed = [];
      }
      const puzzle = availablePuzzles[Math.floor(Math.random() * availablePuzzles.length)];
      gameData.puzzleQuestionsUsed.push(puzzleQuestions.indexOf(puzzle));

      // æ˜¾ç¤ºè°œé¢˜
      instructionEl.innerHTML = `<span class="level-badge">ç¬¬ ${level + 1} å…³å¥–åŠ±</span> å®Œæˆå…³å¡ï¼ŒæŒ‘æˆ˜è°œé¢˜ï¼`;
      questionEl.textContent = puzzle.question;
      definitionEl.textContent = "è¯·é€‰æ‹©æ­£ç¡®ç­”æ¡ˆï¼š";
      phoneticEl.textContent = "";
      letterBox.innerHTML = "";

      // ç”Ÿæˆé€‰é¡¹
      puzzle.options.forEach(option => {
        const btn = document.createElement("button");
        btn.className = "game-btn bg-gray-200 text-gray-700 w-full text-left mb-2";
        btn.textContent = option;
        btn.onclick = () => checkPuzzleAnswer(puzzle, option);
        optionsEl.appendChild(btn);
      });
    }

    // æ£€æŸ¥è°œé¢˜ç­”æ¡ˆ
    function checkPuzzleAnswer(puzzle, selected) {
      const buttons = optionsEl.querySelectorAll("button");
      buttons.forEach(btn => {
        btn.disabled = true;
        if (btn.textContent === puzzle.answer) {
          btn.className = "game-btn bg-green-500 text-white w-full text-left mb-2";
        } else if (btn.textContent === selected) {
          btn.className = "game-btn bg-red-500 text-white w-full text-left mb-2";
        }
      });

      // å¤„ç†ç»“æœ
      if (selected === puzzle.answer) {
        resultEl.className = "mt-4 p-4 rounded-lg bg-green-100 text-green-800";
        resultEl.textContent = "ğŸ‰ æ­å–œä½ ç­”å¯¹äº†ï¼è·å¾—é¢å¤–æ˜Ÿæ˜Ÿï¼";
        correctSound.play();
        // å¥–åŠ±æ˜Ÿæ˜Ÿ
        levelStars[level] = Math.min((levelStars[level] || 0) + 1, 3);
      } else {
        resultEl.className = "mt-4 p-4 rounded-lg bg-red-100 text-red-800";
        resultEl.textContent = `âŒ æ­£ç¡®ç­”æ¡ˆæ˜¯ï¼š${puzzle.answer}`;
        wrongSound.play();
      }

      // è¿›å…¥ä¸‹ä¸€å…³
      setTimeout(() => {
        level++;
        levelCorrect = 0;
        currentIndex = level * 5;
        inPuzzle = false;
        saveProgress();
        loadNext();
      }, 1500);
    }

    // è¯­éŸ³è¯†åˆ«åˆå§‹åŒ–
    function initSpeechRecognition() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        startReadingBtn.disabled = true;
        startReadingBtn.title = "ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«";
        return;
      }

      recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.lang = 'en-US';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript.toLowerCase();
        
        // è·å–å½“å‰å•è¯ï¼ˆè½¬ä¸ºå°å†™ï¼‰
        const currentWord = isReviewMode 
          ? wrongList[currentReviewIndex].word.toLowerCase()
          : wordFiles[currentFile].words[currentIndex].word.toLowerCase();
        
        // æ£€æŸ¥è¯­éŸ³æ˜¯å¦åŒ¹é…å•è¯ï¼ˆåŒ…æ‹¬å˜ä½“ï¼‰
        const variants = [currentWord, ...(pronunciationVariants[currentWord] || [])];
        const isMatch = variants.some(variant => 
          transcript.includes(variant) || variant.includes(transcript)
        );

        // å¤„ç†è¯†åˆ«ç»“æœ
        if (isMatch) {
          if (answerCorrect) {
            resultEl.textContent = `ğŸ‰ è¯­éŸ³è¯†åˆ«æˆåŠŸï¼å•è¯ï¼š${currentWord}`;
            setTimeout(() => {
              correctCount++;
              currentStreak++;
              levelCorrect++;
              
              // ç§»é™¤é”™é¢˜ï¼ˆå¦‚æœåœ¨å¤ä¹ æ¨¡å¼ï¼‰
              if (isReviewMode) {
                wrongList = wrongList.filter(w => w.word.toLowerCase() !== currentWord);
              }
              
              saveProgress();
              nextQuestion();
            }, 1000);
          } else {
            resultEl.textContent = `è¯­éŸ³è¯†åˆ«ï¼š${transcript}ï¼Œè¯·å…ˆæ­£ç¡®æ‹¼å†™å•è¯`;
          }
        } else {
          resultEl.textContent = `æœªèƒ½è¯†åˆ«ï¼š"${transcript}"ï¼Œè¯·å°è¯•å†æ¬¡æœ—è¯» "${currentWord}"`;
        }
      };

      recognition.onend = () => {
        isListening = false;
        startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
        startReadingBtn.classList.remove("listening");
      };
    }

    // åˆ‡æ¢è¯­éŸ³è¯†åˆ«çŠ¶æ€
    function toggleListening() {
      if (!recognition) return;
      
      if (isListening) {
        recognition.stop();
        isListening = false;
        startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
        startReadingBtn.classList.remove("listening");
      } else {
        recognition.start();
        isListening = true;
        startReadingBtn.textContent = "æ­£åœ¨è†å¬...";
        startReadingBtn.classList.add("listening");
        resultEl.textContent = "è¯·æœ—è¯»å•è¯...";
      }
    }

    // ä¿å­˜è¿›åº¦
    function saveProgress() {
      gameData = { ...gameData, currentIndex, level, correctCount, wrongList, levelStars };
      localStorage.setItem('wordGameData', JSON.stringify(gameData));
      saveCurrentFileProgress();
    }

    // æ˜¾ç¤ºå¥–åŠ±
    function showReward(streak) {
      const reward = streakRewards[streak];
      rewardMessage.innerHTML = `${reward.description}<br>${reward.action()}`;
      streakReward.classList.remove("hidden");
      rewardSound.play();
    }

    // é¢†å–å¥–åŠ±
    function claimReward() {
      streakReward.classList.add("hidden");
      nextQuestion();
    }

    // æ˜¾ç¤ºé”™é¢˜
    function showMistakes() {
      isReviewMode = true;
      currentReviewIndex = 0;
      loadNext();
    }

    // é€€å‡ºå¤ä¹ æ¨¡å¼
    function exitReview() {
      isReviewMode = false;
      loadNext();
    }

    // é‡ç½®è¿›åº¦
    function resetProgress() {
      if (confirm("ç¡®å®šè¦é‡ç½®å½“å‰å•è¯åº“çš„è¿›åº¦å—ï¼Ÿ")) {
        const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
        delete progressData[currentFile];
        localStorage.setItem('wordFileProgress', JSON.stringify(progressData));
        loadFileProgress();
        loadNext();
      }
    }

    // åˆ é™¤å½“å‰æ–‡ä»¶
    function deleteCurrentFile() {
      if (currentFile === "default") {
        alert("é»˜è®¤å•è¯åº“ä¸èƒ½åˆ é™¤");
        return;
      }
      if (confirm(`ç¡®å®šè¦åˆ é™¤"${wordFiles[currentFile].name}"çš„æ‰€æœ‰æ•°æ®å—ï¼Ÿ`)) {
        const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
        delete progressData[currentFile];
        localStorage.setItem('wordFileProgress', JSON.stringify(progressData));
        wordFiles[currentFile].loaded = false;
        wordFiles[currentFile].words = [];
        currentFile = "default";
        document.getElementById("wordFileSelect").value = "default";
        updateDeleteButton();
        loadFileProgress();
        loadNext();
      }
    }

    // è¯­éŸ³æœ—è¯»åŠŸèƒ½
    function readWord() {
      if (!speechSynthAvailable) return;
      
      // åœæ­¢ä»»ä½•æ­£åœ¨è¿›è¡Œçš„è¯­éŸ³åˆæˆ
      window.speechSynthesis.cancel();
      
      // è·å–å½“å‰å•è¯
      const currentWord = isReviewMode 
        ? wrongList[currentReviewIndex].word
        : wordFiles[currentFile].words[currentIndex].word;
      
      // åˆ›å»ºè¯­éŸ³åˆæˆå®ä¾‹
      const utterance = new SpeechSynthesisUtterance(currentWord);
      utterance.lang = 'en-US';
      utterance.rate = 0.9; // ç¨å¾®é™ä½è¯­é€Ÿï¼Œä¾¿äºå­¦ä¹ 
      
      // è®¾ç½®æœ—è¯»å®Œæˆåçš„å›è°ƒ
      utterance.onend = () => {
        console.log(`æœ—è¯»å®Œæˆ: ${currentWord}`);
      };
      
      utterance.onerror = (event) => {
        console.error(`è¯­éŸ³åˆæˆé”™è¯¯: ${event.error}`);
        resultEl.textContent = "è¯­éŸ³åˆæˆå‡ºé”™ï¼Œè¯·ç¨åå†è¯•";
      };
      
      // å¼€å§‹æœ—è¯»
      window.speechSynthesis.speak(utterance);
    }

    // è®¡ç®—å­—ç¬¦ä¸²ç›¸ä¼¼åº¦
    function calculateSimilarity(s1, s2) {
      if (s1 === s2) return 1;
      const longer = s1.length > s2.length ? s1 : s2;
      const shorter = s1.length > s2.length ? s2 : s1;
      const longerLen = longer.length;
      if (longerLen === 0) return 1.0;
      
      return (longerLen - editDistance(longer, shorter)) / parseFloat(longerLen);
    }

    // ç¼–è¾‘è·ç¦»ç®—æ³•
    function editDistance(s1, s2) {
      s1 = s1.toLowerCase();
      s2 = s2.toLowerCase();
      
      const costs = [];
      for (let i = 0; i <= s1.length; i++) {
        let lastValue = i;
        for (let j = 0; j <= s2.length; j++) {
          if (i === 0) costs[j] = j;
          else {
            if (j > 0) {
              let newValue = costs[j - 1];
              if (s1.charAt(i - 1) !== s2.charAt(j - 1))
                newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
              costs[j - 1] = lastValue;
              lastValue = newValue;
            }
          }
        }
        if (i > 0) costs[s2.length] = lastValue;
      }
      return costs[s2.length];
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¸¸æˆ
    window.onload = init;
  </script>
</body>
</html>
