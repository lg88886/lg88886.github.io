<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å•è¯æ‹¼å†™é—¯å…³æ¸¸æˆ</title>
  <style>
    /* ä¿æŒåŸæœ‰æ ·å¼ä¸å˜ï¼Œæ–°å¢å‘éŸ³åˆ‡æ¢æŒ‰é’®æ ·å¼ */
    .accent-switch {
      background-color: #ff9800;
    }
    .accent-switch:hover {
      background-color: #e68900;
    }
  </style>
</head>
<body>
<div id="game-container">
  <h1>å•è¯æ‹¼å†™é—¯å…³æ¸¸æˆ</h1>
  <audio id="bgm" autoplay loop>
    <source src="https://cdn.pixabay.com/audio/2022/10/30/audio_46fdd201cc.mp3" type="audio/mpeg">
  </audio>
  <audio id="correct-sound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_e0b6f67a53.mp3"></audio>
  <audio id="wrong-sound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_2307f9b816.mp3"></think>
  
  <!-- æ–‡ä»¶é€‰æ‹©åŒºåŸŸä¿æŒä¸å˜ -->
  <div id="fileSelector" style="margin-bottom: 15px;">
    <label>é€‰æ‹©å•è¯æ–‡ä»¶ï¼š</label>
    <select id="wordFileSelect" onchange="loadSelectedWordFile()">
      <option value="default">é»˜è®¤å•è¯åº“</option>
    </select>
    <button onclick="deleteCurrentFile()" id="deleteFileBtn" style="background-color: #f44336;">åˆ é™¤æ–‡ä»¶è¿›åº¦</button>
    <div id="fileNotification" class="file-notification"></div>
  </div>
  
  <div id="content">
    <div id="instruction"></div>
    <div id="definition"></div>
    <div id="phonetic"></div>
    <div id="question"></div>
    <div class="letter-box" id="letterBox"></div>
    <div class="navigation-buttons">
      <button onclick="prevQuestion()" id="prevBtn">ä¸Šä¸€é¢˜</button>
      <button onclick="toggleListening()" id="startReadingBtn" style="display:none">å¼€å§‹æœ—è¯»</button>
      <button onclick="submitAnswer()" id="nextBtn">è·³è¿‡æ­¤é¢˜</button>
      <button onclick="readWord()">ğŸ”Š å¬å•è¯</button>
      <!-- æ–°å¢ï¼šè‹±/ç¾å¼å‘éŸ³åˆ‡æ¢æŒ‰é’® -->
      <button onclick="toggleAccent()" class="accent-switch" id="accentBtn">åˆ‡æ¢ä¸ºè‹±å¼å‘éŸ³</button>
      <button onclick="resetProgress()" class="reset-btn">é‡ç½®è¿›åº¦</button>
      <button onclick="exitReview()" class="review-btn" style="display:none">è¿”å›é—¯å…³</button>
      <button onclick="showMistakes()" class="review-btn">ğŸ“– æŸ¥çœ‹é”™é¢˜æœ¬</button>
    </div>
    <div id="options"></div>
    <div id="result"></div>
    <div id="stats"></div>
  </div>
</div>
<script>
  // åŸå§‹å•è¯åˆ—è¡¨ï¼ˆåŒ…å«éŸ³æ ‡ï¼‰
  const defaultWordList = [
    {word:"morning", definition:"æ—©æ™¨ï¼›ä¸Šåˆ", phonetic:"/ËˆmÉ”ËnÉªÅ‹/"},
    {word:"afternoon", definition:"åˆåï¼›ä¸‹åˆ", phonetic:"/ËŒÉ‘ËftÉ™ËˆnuËn/"},
    {word:"evening", definition:"æ™šä¸Šï¼›å‚æ™š", phonetic:"/ËˆiËvnÉªÅ‹/"},
    {word:"night", definition:"å¤œé—´ï¼›å¤œæ™š", phonetic:"/naÉªt/"},
    {word:"fine", definition:"å¥½çš„", phonetic:"/faÉªn/"},
    {word:"thank", definition:"æ„Ÿè°¢", phonetic:"/Î¸Ã¦Å‹k/"},
    {word:"goodbye", definition:"å†è§", phonetic:"/ËŒÉ¡ÊŠdËˆbaÉª/"},
    {word:"woof", definition:"ç‹—å«å£°", phonetic:"/wÊŠf/"},
    {word:"Mrs", definition:"å¤«äººï¼›å¤ªå¤ª", phonetic:"/ËˆmÉªsÉªz/"},
    {word:"day", definition:"ä¸€å¤©", phonetic:"/deÉª/"},
    {word:"today", definition:"ä»Šå¤©", phonetic:"/tÉ™ËˆdeÉª/"},
  ];

  // è°œé¢˜åˆ—è¡¨ä¿æŒä¸å˜
  const puzzleQuestions = [
    { question: "â€œæ—¥å‡ºå¤§ç±³â€çŒœä¸€ä¸ªå­—ï¼Ÿ", options: ["æ˜", "æ˜Œ", "æ—©", "äº®"], answer: "æ˜Œ" },
    { question: "ä»€ä¹ˆä¸œè¥¿äººä»¬éƒ½ä¸å–œæ¬¢åƒï¼Ÿ", options: ["ç³–", "äº", "é¥¼å¹²", "å·§å…‹åŠ›"], answer: "äº" },
    // å…¶ä»–è°œé¢˜ä¿æŒä¸å˜...
  ];

  // å¤šæ–‡ä»¶æ”¯æŒä¿æŒä¸å˜
  const predefinedWordFiles = [
    {id: "two", name: "äºŒå¹´çº§å•è¯", filename: "two_words.txt"},
    {id: "basic", name: "æ–°æ¦‚å¿µ1è¯åº“", filename: "basic_words.txt"},
  ];

  // æ–°å¢ï¼šå‘éŸ³è®¾ç½®
  let currentAccent = 'us'; // é»˜è®¤ç¾å¼å‘éŸ³
  const accentNames = {
    'us': 'ç¾å¼',
    'gb': 'è‹±å¼'
  };

  // å•è¯æ–‡ä»¶å­˜å‚¨ä¿æŒä¸å˜
  let wordFiles = {
    "default": { name: "é»˜è®¤å•è¯åº“", words: defaultWordList, isCustom: false }
  };
  let currentFile = "default";

  // æ¸¸æˆå˜é‡ - ä»æœ¬åœ°å­˜å‚¨åŠ è½½æˆ–åˆå§‹åŒ–ï¼ˆå¢åŠ å‘éŸ³è®¾ç½®å­˜å‚¨ï¼‰
  let gameData = JSON.parse(localStorage.getItem('wordGameData')) || {
    currentIndex: 0,
    level: 0,
    correctCount: 0,
    wrongList: [],
    levelStars: [],
    puzzleQuestionsUsed: [],
    currentAccent: 'us' // ä¿å­˜ç”¨æˆ·çš„å‘éŸ³åå¥½
  };

  // åŒæ­¥å˜é‡åˆ°å†…å­˜ï¼ˆåŒ…å«å‘éŸ³è®¾ç½®ï¼‰
  let currentIndex = gameData.currentIndex;
  let level = gameData.level;
  let inPuzzle = false;
  let correctCount = gameData.correctCount;
  let wrongList = gameData.wrongList;
  let isReviewMode = false;
  let currentStreak = 0;
  let levelStars = gameData.levelStars;
  let currentReviewIndex = 0;
  let levelCorrect = 0;
  let recognition; // è¯­éŸ³è¯†åˆ«å¯¹è±¡
  let isListening = false;
  currentAccent = gameData.currentAccent || 'us'; // åŠ è½½ä¿å­˜çš„å‘éŸ³åå¥½

  // åˆå§‹åŒ–å‘éŸ³æŒ‰é’®æ˜¾ç¤º
  function updateAccentButton() {
    const btn = document.getElementById('accentBtn');
    const opposite = currentAccent === 'us' ? 'gb' : 'us';
    btn.textContent = `åˆ‡æ¢ä¸º${accentNames[opposite]}å‘éŸ³`;
  }

  // åˆ‡æ¢å‘éŸ³æ–¹å¼
  function toggleAccent() {
    currentAccent = currentAccent === 'us' ? 'gb' : 'us';
    gameData.currentAccent = currentAccent;
    localStorage.setItem('wordGameData', JSON.stringify(gameData));
    updateAccentButton();
    // ç«‹å³æ’­æ”¾å½“å‰å•è¯çš„æ–°å‘éŸ³
    readWord();
  }

  // åˆå§‹åŒ–æ–‡ä»¶é€‰æ‹©å™¨ä¿æŒä¸å˜
  function initFileSelector() {
    const selectEl = document.getElementById("wordFileSelect");
    const fileProgress = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
    
    const defaultOption = selectEl.querySelector('option[value="default"]');
    selectEl.innerHTML = '';
    selectEl.appendChild(defaultOption);
    
    const addedOptions = new Set(['default']);
    
    predefinedWordFiles.forEach(file => {
      if (!wordFiles[file.id]) {
        wordFiles[file.id] = {
          name: file.name,
          filename: file.filename,
          words: [],
          isCustom: true,
          loaded: false
        };
      }
      
      if (!addedOptions.has(file.id)) {
        const option = document.createElement("option");
        option.value = file.id;
        option.textContent = file.name;
        selectEl.appendChild(option);
        addedOptions.add(file.id);
      }
    });
    
    const savedFiles = JSON.parse(localStorage.getItem('customWordFiles') || '{}');
    Object.keys(savedFiles).forEach(key => {
      if (!wordFiles[key]) {
        wordFiles[key] = savedFiles[key];
      }
      
      if (!addedOptions.has(key)) {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = wordFiles[key].name;
        selectEl.appendChild(option);
        addedOptions.add(key);
      }
    });
    
    selectEl.value = currentFile;
    updateDeleteButton();
    updateAccentButton(); // åˆå§‹åŒ–å‘éŸ³æŒ‰é’®
  }

  // æ–‡ä»¶å¤„ç†ç›¸å…³å‡½æ•°ä¿æŒä¸å˜ï¼ˆloadSelectedWordFile, saveCurrentFileProgressç­‰ï¼‰
  function loadSelectedWordFile() {
    const selectedFile = document.getElementById("wordFileSelect").value;
    if (selectedFile && wordFiles[selectedFile] && selectedFile !== currentFile) {
      saveCurrentFileProgress();
      currentFile = selectedFile;
      fileNotification.textContent = "";
      
      const file = wordFiles[currentFile];
      if (!file.loaded && file.filename) {
        loadWordFileFromServer(file);
        return;
      }
      
      loadFileProgress();
      isReviewMode = false;
      updateDeleteButton();
      loadNext();
    }
  }

  function saveCurrentFileProgress() {
    const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
    progressData[currentFile] = {
      currentIndex,
      level,
      correctCount,
      wrongList,
      levelStars,
      puzzleQuestionsUsed: puzzleQuestions
        .map((q, i) => q.used ? i : null)
        .filter(i => i !== null)
    };
    localStorage.setItem('wordFileProgress', JSON.stringify(progressData));
  }

  function loadFileProgress() {
    const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
    const fileProgress = progressData[currentFile] || {};
    
    currentIndex = fileProgress.currentIndex || 0;
    level = fileProgress.level || 0;
    correctCount = fileProgress.correctCount || 0;
    wrongList = fileProgress.wrongList || [];
    levelStars = fileProgress.levelStars || [];
    
    if (fileProgress.puzzleQuestionsUsed) {
      puzzleQuestions.forEach((q, i) => {
        q.used = fileProgress.puzzleQuestionsUsed.includes(i);
      });
    }
  }

  function deleteCurrentFile() {
    if (currentFile === "default") {
      alert("é»˜è®¤å•è¯åº“ä¸èƒ½åˆ é™¤");
      return;
    }
    
    if (confirm(`ç¡®å®šè¦åˆ é™¤"${wordFiles[currentFile].name}"çš„è¿›åº¦æ•°æ®å—ï¼Ÿ`)) {
      const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
      delete progressData[currentFile];
      localStorage.setItem('wordFileProgress', JSON.stringify(progressData));
      
      loadFileProgress();
      isReviewMode = false;
      loadNext();
    }
  }

  function loadWordFileFromServer(file) {
    fileNotification.textContent = `æ­£åœ¨åŠ è½½ ${file.name}...`;
    
    const xhr = new XMLHttpRequest();
    xhr.open('GET', file.filename, true);
    
    xhr.onload = function() {
      if (xhr.status === 200) {
        try {
          const content = xhr.responseText;
          const words = [];
          const lines = content.split('\n');
          
          lines.forEach(line => {
            if (line.trim()) {
              const [word, definition, phonetic] = line.split(',');
              if (word && definition) {
                words.push({ 
                  word: word.trim(), 
                  definition: definition.trim(),
                  phonetic: phonetic ? phonetic.trim() : 'æ— éŸ³æ ‡'
                });
              }
            }
          });
          
          if (words.length > 0) {
            file.words = words;
            file.loaded = true;
            
            const savedFiles = JSON.parse(localStorage.getItem('customWordFiles') || '{}');
            savedFiles[file.id] = {
              name: file.name,
              filename: file.filename,
              words: words,
              isCustom: true,
              loaded: true
            };
            localStorage.setItem('customWordFiles', JSON.stringify(savedFiles));
            
            fileNotification.textContent = `${file.name} åŠ è½½æˆåŠŸï¼å…± ${words.length} ä¸ªå•è¯ã€‚`;
            loadFileProgress();
            isReviewMode = false;
            updateDeleteButton();
            loadNext();
          } else {
            fileNotification.textContent = `é”™è¯¯ï¼š${file.name} æ ¼å¼ä¸æ­£ç¡®`;
          }
        } catch (error) {
          console.error("è§£ææ–‡ä»¶é”™è¯¯:", error);
          fileNotification.textContent = `é”™è¯¯ï¼šæ— æ³•è§£æ ${file.name}`;
        }
      } else if (xhr.status === 404) {
        fileNotification.textContent = `é”™è¯¯ï¼šæœªæ‰¾åˆ° ${file.name}`;
      } else {
        fileNotification.textContent = `é”™è¯¯ï¼šåŠ è½½ ${file.name} å¤±è´¥ï¼ŒçŠ¶æ€ç : ${xhr.status}`;
      }
    }
    
    xhr.onerror = function() {
      fileNotification.textContent = `é”™è¯¯ï¼šåŠ è½½ ${file.name} å¤±è´¥`;
    }
    
    xhr.send();
  }

  // ä¿å­˜æ¸¸æˆè¿›åº¦ä¿æŒä¸å˜
  function saveProgress() {
    gameData.currentIndex = currentIndex;
    gameData.level = level;
    gameData.correctCount = correctCount;
    gameData.wrongList = wrongList;
    gameData.levelStars = levelStars;
    gameData.puzzleQuestionsUsed = puzzleQuestions
      .map((q, i) => q.used ? i : null)
      .filter(i => i !== null);
    gameData.currentAccent = currentAccent; // ä¿å­˜å‘éŸ³åå¥½
    
    saveCurrentFileProgress();
    localStorage.setItem('wordGameData', JSON.stringify(gameData));
  }

  // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ä¿æŒä¸å˜
  function updateStats() {
    const currentWords = wordFiles[currentFile].words;
    statsEl.textContent = `æ­£ç¡®ï¼š${correctCount}  é”™è¯¯ï¼š${wrongList.length}  è¿›åº¦ï¼š${currentIndex + 1} / ${currentWords.length}`;
  }

  // åŠ è½½ä¸‹ä¸€é¢˜ä¿æŒä¸å˜
  function loadNext() {
    resultEl.textContent = "";
    optionsEl.innerHTML = "";
    letterBox.innerHTML = "";
    updateStats();
    startReadingBtn.style.display = "none";
    isListening = false;
    startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
    startReadingBtn.classList.remove("listening");
    
    nextBtn.style.display = "inline-block";
    nextBtn.disabled = false;
    nextBtn.textContent = isReviewMode ? "ä¸‹ä¸€ä¸ªé”™é¢˜" : "è·³è¿‡æ­¤é¢˜";
    
    if (isReviewMode) {
      prevBtn.disabled = currentReviewIndex <= 0;
    } else {
      prevBtn.disabled = currentIndex <= 0;
    }

    if (isReviewMode) {
      document.querySelector('button[onclick="exitReview()"]').style.display = "inline-block";
      if (wrongList.length === 0) {
        instructionEl.textContent = "ğŸ‰ æ­å–œä½ æ”»å…‹äº†æ‰€æœ‰é”™é¢˜ï¼";
        definitionEl.textContent = "ç»§ç»­åŠ æ²¹å“¦ï¼";
        phoneticEl.textContent = "";
        questionEl.textContent = "";
        nextBtn.style.display = "none";
        prevBtn.style.display = "none";
        return;
      }
      
      if (currentReviewIndex >= wrongList.length) {
        currentReviewIndex = 0;
      }
      const wordObj = wrongList[currentReviewIndex];
      instructionEl.textContent = `é”™é¢˜å›é¡¾ ç¬¬ ${currentReviewIndex + 1}/${wrongList.length} é¢˜`;
      definitionEl.textContent = `ä¸­æ–‡æç¤ºï¼š${wordObj.definition}`;
      phoneticEl.textContent = `éŸ³æ ‡ï¼š${wordObj.phonetic || 'æ— '}`;
      questionEl.textContent = "è¯·è¡¥å…¨å•è¯ï¼š";
      
      const first = document.createElement("input");
      first.type = "text";
      first.maxLength = 1;
      first.className = "fixed-letter";
      first.value = wordObj.word[0];
      first.readOnly = true;
      letterBox.appendChild(first);

      for (let i = 1; i < wordObj.word.length; i++) {
        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 1;
        input.className = "letter-input";
        input.dataset.index = i;
        addInputListeners(input);
        letterBox.appendChild(input);
      }
      letterBox.querySelector("input.letter-input")?.focus();
      
      setTimeout(() => readWord(), 500);
      return;
    }

    document.querySelector('button[onclick="exitReview()"]').style.display = "none";
    const start = level * 8;
    if (currentIndex - start >= 8) {
      showPuzzle();
      return;
    }
    if (currentIndex >= wordFiles[currentFile].words.length) {
      instructionEl.textContent = "ğŸ‰ æ­å–œä½ å®Œæˆæ‰€æœ‰å•è¯ï¼";
      definitionEl.innerHTML = `æ€»æ˜Ÿçº§ï¼š${levelStars.reduce((a, b) => a + b, 0)}/${levelStars.length * 3} â­`;
      phoneticEl.textContent = "";
      questionEl.textContent = "";
      nextBtn.style.display = "none";
      prevBtn.style.display = "none";
      return;
    }

    const currentWords = wordFiles[currentFile].words;
    const wordObj = currentWords[currentIndex];
    instructionEl.textContent = `ç¬¬ ${level + 1} å…³ ç¬¬ ${currentIndex - start + 1}/${Math.min(8, currentWords.length - start)} é¢˜`;
    definitionEl.textContent = `ä¸­æ–‡æç¤ºï¼š${wordObj.definition}`;
    phoneticEl.textContent = `éŸ³æ ‡ï¼š${wordObj.phonetic || 'æ— '}`;
    questionEl.textContent = "è¯·è¡¥å…¨å•è¯ï¼š";

    const first = document.createElement("input");
    first.type = "text";
    first.maxLength = 1;
    first.className = "fixed-letter";
    first.value = wordObj.word[0];
    first.readOnly = true;
    letterBox.appendChild(first);

    for (let i = 1; i < wordObj.word.length; i++) {
      const input = document.createElement("input");
      input.type = "text";
      input.maxLength = 1;
      input.className = "letter-input";
      input.dataset.index = i;
      addInputListeners(input);
      letterBox.appendChild(input);
    }
    letterBox.querySelector("input.letter-input")?.focus();
    
    setTimeout(() => readWord(), 500);
    return;
  }

  // ä¸Šä¸€é¢˜åŠŸèƒ½ä¿æŒä¸å˜
  function prevQuestion() {
    if (isReviewMode) {
      if (currentReviewIndex > 0) {
        currentReviewIndex--;
        loadNext();
      }
      return;
    }
    
    if (currentIndex > 0) {
      const currentWords = wordFiles[currentFile].words;
      const currentWord = currentWords[currentIndex];
      const isAlreadyInWrong = wrongList.some(item => item.word === currentWord.word);
      
      if (!isAlreadyInWrong && currentStreak > 0) {
        correctCount--;
        currentStreak--;
      }
      
      currentIndex--;
      saveProgress();
      loadNext();
    }
  }

  // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è¾“å…¥æ¡†éƒ½å·²å¡«æ»¡ä¿æŒä¸å˜
  function checkAllFilled() {
    const inputs = letterBox.querySelectorAll("input.letter-input");
    for (let input of inputs) {
      if (!input.value) return false;
    }
    return true;
  }

  // è·³è¿‡å½“å‰é¢˜ç›®ä¿æŒä¸å˜
  function submitAnswer() {
    if (isReviewMode) {
      currentReviewIndex++;
      loadNext();
      return;
    }
    
    if (inPuzzle) {
      level++;
      levelCorrect = 0;
      currentIndex = level * 8;
      inPuzzle = false;
      saveProgress();
      loadNext();
      return;
    }
    
    const currentWords = wordFiles[currentFile].words;
    const currentWord = currentWords[currentIndex];
    const isAlreadyInWrong = wrongList.some(item => item.word === currentWord.word);
    if (!isAlreadyInWrong) {
      wrongList.push(currentWord);
    }
    
    currentStreak = 0;
    currentIndex++;
    saveProgress();
    loadNext();
  }

  // è‡ªåŠ¨æ£€æŸ¥ç­”æ¡ˆä¿æŒä¸å˜
  function autoCheckAnswer() {
    if (!checkAllFilled()) return;
    
    const currentWords = wordFiles[currentFile].words;
    const wordObj = isReviewMode 
      ? wrongList[currentReviewIndex] 
      : currentWords[currentIndex];
    
    const inputs = letterBox.querySelectorAll("input.letter-input");
    let filled = "";
    inputs.forEach(input => filled += input.value || "");
    const userAns = (wordObj.word[0] + filled).toLowerCase();

    if (userAns === wordObj.word.toLowerCase()) {
      resultEl.textContent = "âœ… æ‹¼å†™æ­£ç¡®ï¼è¯·ç‚¹å‡»å¼€å§‹æœ—è¯»";
      correctSound.play();
      startReadingBtn.style.display = "inline-block";
    } else {
      resultEl.textContent = "âŒ æ‹¼å†™é”™è¯¯ï¼Œè¯·é‡æ–°å¡«å†™";
      wrongSound.play();
      inputs.forEach(input => {
        input.value = "";
      });
      letterBox.querySelector("input.letter-input")?.focus();
    }
  }

  // åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«ä¿æŒä¸å˜
  function initRecognition() {
    if ('webkitSpeechRecognition' in window) {
      recognition = new webkitSpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';
      
      recognition.onresult = function(event) {
        const transcript = event.results[0][0].transcript.trim().toLowerCase();
        processRecognitionResult(transcript);
      };
      
      recognition.onend = function() {
        isListening = false;
        startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
        startReadingBtn.classList.remove("listening");
      };
      
      recognition.onerror = function(event) {
        console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
        resultEl.textContent = "è¯­éŸ³è¯†åˆ«å‡ºé”™ï¼Œè¯·é‡è¯•";
        isListening = false;
        startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
        startReadingBtn.classList.remove("listening");
      };
    } else {
      resultEl.textContent = "æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½";
      startReadingBtn.disabled = true;
    }
  }

  // å¢å¼ºï¼šè¯­éŸ³è¯†åˆ«å®¹é”™å¤„ç†ï¼ˆåŸºäºç¼–è¾‘è·ç¦»ç®—æ³•ï¼‰
  function levenshteinDistance(s, t) {
    if (s === t) return 0;
    if (s.length === 0) return t.length;
    if (t.length === 0) return s.length;

    const v0 = new Array(t.length + 1);
    const v1 = new Array(t.length + 1);

    for (let i = 0; i < v0.length; i++) v0[i] = i;
    for (let i = 0; i < v1.length; i++) v1[i] = 0;

    for (let i = 0; i < s.length; i++) {
      v1[0] = i + 1;
      for (let j = 0; j < t.length; j++) {
        const cost = (s[i] === t[j]) ? 0 : 1;
        v1[j + 1] = Math.min(
          v1[j] + 1,        // æ’å…¥
          v0[j + 1] + 1,    // åˆ é™¤
          v0[j] + cost      // æ›¿æ¢
        );
      }
      [v0, v1] = [v1, v0];
    }
    return v0[t.length];
  }

  // å¤„ç†è¯­éŸ³è¯†åˆ«ç»“æœï¼ˆå¢åŠ å®¹é”™é€»è¾‘ï¼‰
  function processRecognitionResult(transcript) {
    const currentWords = wordFiles[currentFile].words;
    const wordObj = isReviewMode 
      ? wrongList[currentReviewIndex] 
      : currentWords[currentIndex];
    
    const targetWord = wordObj.word.toLowerCase();
    const distance = levenshteinDistance(transcript, targetWord);
    const maxAllowedDistance = Math.min(2, Math.floor(targetWord.length / 3)); // æ ¹æ®å•è¯é•¿åº¦åŠ¨æ€è°ƒæ•´å®¹é”™ç¨‹åº¦
    
    // å®¹é”™é€»è¾‘ï¼šå®Œå…¨åŒ¹é…æˆ–ç¼–è¾‘è·ç¦»åœ¨å…è®¸èŒƒå›´å†…
    if (transcript === targetWord || distance <= maxAllowedDistance) {
      resultEl.textContent = `âœ… æœ—è¯»æ­£ç¡®ï¼ï¼ˆæ£€æµ‹åˆ°: "${transcript}"ï¼‰`;
      correctSound.play();
      
      setTimeout(() => {
        if (isReviewMode) {
          wrongList.splice(currentReviewIndex, 1);
          if (wrongList.length === 0) {
            instructionEl.textContent = "ğŸ‰ æ­å–œä½ æ”»å…‹äº†æ‰€æœ‰é”™é¢˜ï¼";
            definitionEl.textContent = "ç»§ç»­åŠ æ²¹å“¦ï¼";
            phoneticEl.textContent = "";
            questionEl.textContent = "";
            return;
          }
          loadNext();
        } else {
          correctCount++;
          currentStreak++;
          levelCorrect++;
          currentIndex++;
          saveProgress();
          loadNext();
        }
      }, 1000);
    } else {
      resultEl.textContent = `âŒ æœ—è¯»ä¸æ­£ç¡®ï¼ˆä½ è¯»çš„æ˜¯: "${transcript}"ï¼‰ï¼Œè¯·å†è¯•ä¸€æ¬¡`;
      wrongSound.play();
    }
  }

  // åˆ‡æ¢è¯­éŸ³è¯†åˆ«çŠ¶æ€ä¿æŒä¸å˜
  function toggleListening() {
    if (!recognition) {
      initRecognition();
    }
    
    if (isListening) {
      window.speechSynthesis.cancel();
      recognition.stop();
      isListening = false;
      startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
      startReadingBtn.classList.remove("listening");
      resultEl.textContent = "æœ—è¯»å·²åœæ­¢ï¼Œè¯·é‡æ–°ç‚¹å‡»å¼€å§‹æœ—è¯»";
    } else {
      try {
        recognition.start();
        isListening = true;
        startReadingBtn.textContent = "ç»“æŸæœ—è¯»";
        startReadingBtn.classList.add("listening");
        resultEl.textContent = "è¯·æœ—è¯»å•è¯...";
      } catch (e) {
        resultEl.textContent = "æ— æ³•å¯åŠ¨è¯­éŸ³è¯†åˆ«ï¼Œè¯·é‡è¯•";
        console.error('å¯åŠ¨è¯­éŸ³è¯†åˆ«å¤±è´¥:', e);
      }
    }
  }

  // å¢å¼ºï¼šä½¿ç”¨Oxfordè¯å…¸å‘éŸ³
  function readWord() {
    const currentWords = wordFiles[currentFile].words;
    const wordObj = isReviewMode 
      ? wrongList[currentReviewIndex] 
      : currentWords[currentIndex];
    
    if (!wordObj || !wordObj.word) return;
    
    const word = wordObj.word.toLowerCase();
    const audioUrl = `https://ssl.gstatic.com/dictionary/static/sounds/oxford/${word}--_${currentAccent}_1.mp3`;
    
    // åˆ›å»ºä¸´æ—¶éŸ³é¢‘å…ƒç´ æ’­æ”¾
    const audio = new Audio(audioUrl);
    
    // å¤„ç†å‘éŸ³æ–‡ä»¶ä¸å­˜åœ¨çš„æƒ…å†µï¼ˆfallbackåˆ°è¯­éŸ³åˆæˆï¼‰
    audio.onerror = function() {
      console.log(`æœªæ‰¾åˆ°${accentNames[currentAccent]}å‘éŸ³æ–‡ä»¶ï¼Œä½¿ç”¨è¯­éŸ³åˆæˆ`);
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(word);
      utter.lang = currentAccent === 'us' ? "en-US" : "en-GB";
      utter.rate = 0.9;
      window.speechSynthesis.speak(utter);
    };
    
    audio.play();
  }

  // æ˜¾ç¤ºè°œé¢˜ä¿æŒä¸å˜
  function showPuzzle() {
    inPuzzle = true;
    letterBox.innerHTML = "";
    optionsEl.innerHTML = "";
    definitionEl.textContent = "";
    phoneticEl.textContent = "";
    resultEl.textContent = "";
    startReadingBtn.style.display = "none";
    isListening = false;
    startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
    startReadingBtn.classList.remove("listening");
    
    nextBtn.style.display = "inline-block";
    nextBtn.textContent = "è¿›å…¥ä¸‹ä¸€å…³";
    prevBtn.style.display = "none";

    const rate = levelCorrect / 8;
    let stars = 1;
    if (rate === 1) stars = 3;
    else if (rate >= 0.75) stars = 2;
    levelStars.push(stars);

    const unused = puzzleQuestions.filter(q => !q.used);
    if (unused.length === 0) {
      levelCorrect = 0;
      loadNext();
      return;
    }
    const puzzle = unused[Math.floor(Math.random() * unused.length)];
    puzzle.used = true;
    questionEl.textContent = `ğŸ¯ å…³å¡æŒ‘æˆ˜ï¼š${puzzle.question}`;
    definitionEl.innerHTML = `æœ¬å…³è¯„åˆ†ï¼š${"â­".repeat(stars)}`;

    puzzle.options.forEach(opt => {
      const btn = document.createElement("button");
      btn.textContent = opt;
      btn.className = "option-btn";
      btn.onclick = () => {
        if (opt === puzzle.answer) {
          resultEl.textContent = "ğŸ‰ ç­”å¯¹äº†ï¼Œè¿›å…¥ä¸‹ä¸€å…³ï¼";
          correctSound.play();
          level++;
          levelCorrect = 0;
          currentIndex = level * 8;
          saveProgress();
          setTimeout(() => {
            inPuzzle = false;
            prevBtn.style.display = "inline-block";
            loadNext();
          }, 1000);
        } else {
          resultEl.textContent = "ğŸ˜¥ å†è¯•è¯•ï¼";
          wrongSound.play();
        }
      };
      optionsEl.appendChild(btn);
    });
  }

  // æŸ¥çœ‹é”™é¢˜æœ¬ä¿æŒä¸å˜
  function showMistakes() {
    if (wrongList.length === 0) {
      alert("ç›®å‰æ²¡æœ‰é”™é¢˜ï¼");
      return;
    }
    isReviewMode = true;
    currentReviewIndex = 0;
    loadNext();
  }

  // é€€å‡ºå¤ä¹ æ¨¡å¼ä¿æŒä¸å˜
  function exitReview() {
    isReviewMode = false;
    prevBtn.style.display = "inline-block";
    loadNext();
  }

  // é‡ç½®è¿›åº¦ä¿æŒä¸å˜
  function resetProgress() {
    if (confirm(`ç¡®å®šè¦é‡ç½®"${wordFiles[currentFile].name}"çš„è¿›åº¦å—ï¼Ÿ`)) {
      currentIndex = 0;
      level = 0;
      correctCount = 0;
      wrongList = [];
      levelStars = [];
      puzzleQuestions.forEach(q => q.used = false);
      currentStreak = 0;
      levelCorrect = 0;
      isListening = false;
      startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
      startReadingBtn.classList.remove("listening");
      saveProgress();
      loadNext();
    }
  }

  // è¾“å…¥æ¡†äº‹ä»¶ç›‘å¬ä¿æŒä¸å˜
  function addInputListeners(input) {
    input.addEventListener('input', handleInput);
    input.addEventListener('keydown', handleKeyDown);
    input.addEventListener('compositionstart', () => isComposing = true);
    input.addEventListener('compositionend', (e) => {
      isComposing = false;
      handleInput(e);
    });
  }

  let isComposing = false;
  function handleInput(e) {
    if (isComposing) return;
    const input = e.target;
    input.value = input.value.slice(0, 1).toLowerCase();
    input.classList.add("correct");
    const next = input.nextElementSibling;
    if (next && next.tagName === 'INPUT') next.focus();
    
    autoCheckAnswer();
  }

  function handleKeyDown(e) {
    if (e.key === "Backspace") {
      const input = e.target;
      if (input.value) {
        input.value = "";
        input.classList.remove("correct");
        e.preventDefault();
      } else {
        const prev = input.previousElementSibling;
        if (prev && prev.tagName === 'INPUT' && prev.classList.contains('letter-input')) {
          prev.focus();
          e.preventDefault();
        }
      }
    } else if (e.key === "ArrowLeft") {
      const input = e.target;
      const prev = input.previousElementSibling;
      if (prev && prev.tagName === 'INPUT' && prev.classList.contains('letter-input')) {
        prev.focus();
        e.preventDefault();
      }
    } else if (e.key === "ArrowRight") {
      const input = e.target;
      const next = input.nextElementSibling;
      if (next && next.tagName === 'INPUT' && next.classList.contains('letter-input')) {
        next.focus();
        e.preventDefault();
      }
    }
  }

  // åˆå§‹åŒ–æ¸¸æˆï¼ˆå¢åŠ å‘éŸ³æŒ‰é’®åˆå§‹åŒ–ï¼‰
  initFileSelector();
  loadFileProgress();
  initRecognition();
  updateAccentButton(); // åˆå§‹åŒ–å‘éŸ³æŒ‰é’®æ˜¾ç¤º
  loadNext();
</script>
</body>
</html>
