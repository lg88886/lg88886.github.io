<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å•è¯æ‹¼å†™é—¯å…³æ¸¸æˆ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6', // ä¸»è‰²è°ƒï¼šè“è‰²
            secondary: '#10B981', // è¾…åŠ©è‰²ï¼šç»¿è‰²
            accent: '#F59E0B', // å¼ºè°ƒè‰²ï¼šæ©™è‰²
            danger: '#EF4444', // é”™è¯¯è‰²ï¼šçº¢è‰²
            neutral: '#6B7280', // ä¸­æ€§è‰²ï¼šç°è‰²
            'neutral-light': '#F3F4F6', // æµ…ç°è‰²
            'neutral-dark': '#1F2937', // æ·±ç°è‰²
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
          animation: {
            'pop': 'pop 0.3s ease',
            'streak': 'streak 1s forwards',
            'fade-in': 'fadeIn 0.5s ease-in-out',
            'slide-up': 'slideUp 0.5s ease-out',
          },
          keyframes: {
            pop: {
              '0%, 100%': { transform: 'scale(1)' },
              '50%': { transform: 'scale(1.3)' },
            },
            streak: {
              '0%': { opacity: '0', transform: 'translate(-50%, -20px)' },
              '50%': { opacity: '1', transform: 'translate(-50%, 0)' },
              '100%': { opacity: '0', transform: 'translate(-50%, 20px)' },
            },
            fadeIn: {
              '0%': { opacity: '0' },
              '100%': { opacity: '1' },
            },
            slideUp: {
              '0%': { transform: 'translateY(20px)', opacity: '0' },
              '100%': { transform: 'translateY(0)', opacity: '1' },
            },
          },
        },
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .card-shadow {
        box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05), 0 8px 10px -6px rgba(0, 0, 0, 0.03);
      }
      .btn-hover {
        transition: all 0.3s ease;
      }
      .btn-hover:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      }
      .input-focus:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
      }
      .word-input {
        @apply w-10 h-10 rounded-md border-2 border-gray-300 text-center text-xl font-medium transition-all duration-300;
      }
      .word-input:focus {
        @apply border-primary ring-2 ring-primary/30;
      }
      .word-input.correct {
        @apply border-secondary bg-green-50 animate-pop;
      }
      .word-input.wrong {
        @apply border-danger bg-red-50;
      }
      .fixed-letter {
        @apply word-input bg-gray-100 text-gray-600 cursor-not-allowed;
      }
      .game-btn {
        @apply px-5 py-2.5 rounded-lg font-medium transition-all duration-300 btn-hover focus:outline-none focus:ring-2 focus:ring-offset-2;
      }
      .game-btn-primary {
        @apply game-btn bg-primary text-white focus:ring-primary;
      }
      .game-btn-secondary {
        @apply game-btn bg-secondary text-white focus:ring-secondary;
      }
      .game-btn-accent {
        @apply game-btn bg-accent text-white focus:ring-accent;
      }
      .game-btn-danger {
        @apply game-btn bg-danger text-white focus:ring-danger;
      }
      .game-btn-neutral {
        @apply game-btn bg-gray-200 text-gray-700 focus:ring-gray-400;
      }
      .card {
        @apply bg-white rounded-xl p-6 transition-all duration-500 animate-fade-in card-shadow;
      }
      .card-hover {
        @apply hover:shadow-lg transition-all duration-300;
      }
      .option-btn {
        @apply game-btn w-full mb-2 text-left;
      }
      .streak-effect {
        @apply fixed top-1/4 left-1/2 transform -translate-x-1/2 text-4xl font-bold text-accent opacity-0 pointer-events-none animate-streak;
      }
      .progress-bar {
        @apply h-2 rounded-full overflow-hidden bg-gray-200;
      }
      .progress-fill {
        @apply h-full transition-all duration-500 ease-out;
      }
      .level-badge {
        @apply inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-800;
      }
      .stat-item {
        @apply inline-block mx-2 text-sm text-gray-600;
      }
      .stat-value {
        @apply font-semibold text-gray-800;
      }
      .listening {
        @apply bg-danger animate-pulse;
      }
    }
  </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-50 min-h-screen font-sans">
  <div class="max-w-3xl mx-auto px-4 py-8">
    <!-- æ¸¸æˆæ ‡é¢˜ -->
    <div class="text-center mb-8 animate-fade-in">
      <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-neutral-dark mb-2">
        <i class="fa fa-book text-primary mr-2"></i>å•è¯æ‹¼å†™é—¯å…³æ¸¸æˆ
      </h1>
      <p class="text-neutral text-lg">æå‡ä½ çš„è‹±è¯­è¯æ±‡é‡ï¼ŒæŒ‘æˆ˜è‡ªæˆ‘ï¼</p>
    </div>

    <!-- æ¸¸æˆä¸»å®¹å™¨ -->
    <div class="card mb-6 transform hover:shadow-xl transition-all duration-500">
      <!-- æ–‡ä»¶é€‰æ‹©åŒºåŸŸ -->
      <div class="mb-6 pb-4 border-b border-gray-100">
        <div class="flex flex-col md:flex-row md:items-center justify-between gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">é€‰æ‹©å•è¯æ–‡ä»¶ï¼š</label>
            <select id="wordFileSelect" onchange="loadSelectedWordFile()" class="w-full md:w-auto px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition-all">
              <option value="default">é»˜è®¤å•è¯åº“</option>
              <!-- å…¶ä»–æ–‡ä»¶é€‰é¡¹å°†åŠ¨æ€æ·»åŠ  -->
            </select>
          </div>
          <div class="flex gap-2">
            <button onclick="deleteCurrentFile()" id="deleteFileBtn" class="game-btn-danger">
              <i class="fa fa-trash-o mr-1"></i> åˆ é™¤æ–‡ä»¶è¿›åº¦
            </button>
            <button onclick="resetProgress()" class="game-btn-neutral">
              <i class="fa fa-refresh mr-1"></i> é‡ç½®è¿›åº¦
            </button>
          </div>
        </div>
        <div id="fileNotification" class="mt-2 text-sm text-gray-600"></div>
      </div>

      <!-- æ¸¸æˆå†…å®¹åŒºåŸŸ -->
      <div id="content" class="space-y-6">
        <!-- å…³å¡å’Œé¢˜ç›®ä¿¡æ¯ -->
        <div class="animate-slide-up">
          <div id="instruction" class="text-lg font-semibold text-neutral-dark mb-1"></div>
          <div id="stats" class="flex flex-wrap gap-2 text-sm text-gray-600"></div>
        </div>

        <!-- å•è¯ä¿¡æ¯ -->
        <div class="bg-blue-50 rounded-lg p-4 mb-6 animate-slide-up" style="animation-delay: 0.1s">
          <div id="question" class="text-base font-medium text-neutral-dark mb-2"></div>
          <div id="definition" class="text-lg text-primary font-medium mb-1"></div>
          <div id="phonetic" class="text-base text-indigo-500 italic"></div>
        </div>

        <!-- å•è¯è¾“å…¥åŒºåŸŸ -->
        <div class="flex justify-center mb-6 animate-slide-up" style="animation-delay: 0.2s">
          <div id="letterBox" class="flex gap-2 flex-wrap justify-center"></div>
        </div>

        <!-- æ“ä½œæŒ‰é’® -->
        <div class="flex flex-wrap gap-3 justify-center mb-6 animate-slide-up" style="animation-delay: 0.3s">
          <button onclick="prevQuestion()" id="prevBtn" class="game-btn-neutral">
            <i class="fa fa-arrow-left mr-1"></i> ä¸Šä¸€é¢˜
          </button>
          <button onclick="toggleListening()" id="startReadingBtn" style="display:none" class="game-btn-accent">
            <i class="fa fa-microphone mr-1"></i> å¼€å§‹æœ—è¯»
          </button>
          <button onclick="submitAnswer()" id="nextBtn" class="game-btn-neutral">
            è·³è¿‡æ­¤é¢˜ <i class="fa fa-arrow-right ml-1"></i>
          </button>
          <button onclick="readWord()" class="game-btn-primary">
            <i class="fa fa-volume-up mr-1"></i> å¬å•è¯
          </button>
          <button onclick="showMistakes()" class="game-btn-secondary">
            <i class="fa fa-book mr-1"></i> æŸ¥çœ‹é”™é¢˜æœ¬
          </button>
          <button onclick="exitReview()" class="game-btn-secondary" style="display:none">
            <i class="fa fa-arrow-left mr-1"></i> è¿”å›é—¯å…³
          </button>
        </div>

        <!-- ç›¸ä¼¼åº¦æŒ‡ç¤ºå™¨ -->
        <div class="similarity-meter progress-bar mb-6 animate-slide-up" style="animation-delay: 0.4s; display: none">
          <div class="similarity-fill progress-fill bg-primary" id="similarityFill"></div>
        </div>

        <!-- é€‰é¡¹åŒºåŸŸ -->
        <div id="options" class="space-y-2 animate-slide-up" style="animation-delay: 0.5s"></div>

        <!-- ç»“æœåŒºåŸŸ -->
        <div id="result" class="mt-4 p-4 rounded-lg text-center font-medium animate-slide-up" style="animation-delay: 0.6s"></div>
      </div>
    </div>

    <!-- åº•éƒ¨ä¿¡æ¯ -->
    <div class="text-center text-gray-500 text-sm mt-8 animate-fade-in">
      <p>å•è¯æ‹¼å†™é—¯å…³æ¸¸æˆ Â© 2025 | æå‡ä½ çš„è‹±è¯­è¯æ±‡é‡</p>
    </div>
  </div>

  <!-- éŸ³é¢‘å…ƒç´  -->
  <audio id="bgm" autoplay loop>
    <source src="https://cdn.pixabay.com/audio/2022/10/30/audio_46fdd201cc.mp3" type="audio/mpeg">
  </audio>
  <audio id="correct-sound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_e0b6f67a53.mp3"></audio>
  <audio id="wrong-sound" src="https://cdn.pixabay.com/audio/2022/03/15/audio_2307f9b816.mp3"></audio>

  <!-- è¿ç»­æ­£ç¡®æç¤º -->
  <div id="streakEffect" class="streak-effect"></div>

  <script>
    // åŸå§‹å•è¯åˆ—è¡¨ï¼ˆåŒ…å«éŸ³æ ‡ï¼‰
    const defaultWordList = [
      {word:"morning", definition:"æ—©æ™¨ï¼›ä¸Šåˆ", phonetic:"/ËˆmÉ”ËnÉªÅ‹/"},
      {word:"afternoon", definition:"åˆåï¼›ä¸‹åˆ", phonetic:"/ËŒÉ‘ËftÉ™ËˆnuËn/"},
      {word:"evening", definition:"æ™šä¸Šï¼›å‚æ™š", phonetic:"/ËˆiËvnÉªÅ‹/"},
      {word:"night", definition:"å¤œé—´ï¼›å¤œæ™š", phonetic:"/naÉªt/"},
      {word:"fine", definition:"å¥½çš„", phonetic:"/faÉªn/"},
      {word:"thank", definition:"æ„Ÿè°¢", phonetic:"/Î¸Ã¦Å‹k/"},
      {word:"goodbye", definition:"å†è§", phonetic:"/ËŒÉ¡ÊŠdËˆbaÉª/"},
      {word:"woof", definition:"ç‹—å«å£°", phonetic:"/wÊŠf/"},
      {word:"Mrs", definition:"å¤«äººï¼›å¤ªå¤ª", phonetic:"/ËˆmÉªsÉªz/"},
      {word:"day", definition:"ä¸€å¤©", phonetic:"/deÉª/"},
      {word:"today", definition:"ä»Šå¤©", phonetic:"/tÉ™ËˆdeÉª/"},
    ];

    const puzzleQuestions = [
      { question: "â€œæ—¥å‡ºå¤§ç±³â€çŒœä¸€ä¸ªå­—ï¼Ÿ", options: ["æ˜", "æ˜Œ", "æ—©", "äº®"], answer: "æ˜Œ" },
      { question: "ä»€ä¹ˆä¸œè¥¿äººä»¬éƒ½ä¸å–œæ¬¢åƒï¼Ÿ", options: ["ç³–", "äº", "é¥¼å¹²", "å·§å…‹åŠ›"], answer: "äº" },
      { question: "ä»€ä¹ˆä¸œè¥¿è¶Šæ´—è¶Šè„ï¼Ÿ", options: ["è¡£æœ", "æ‰‹", "æ°´", "åœ°æ¿"], answer: "æ°´" },
      { question: "å“ªç§ç‹—ä¸ä¼šå«ï¼Ÿ", options: ["çƒ­ç‹—", "è—ç’", "å“ˆå£«å¥‡", "ç‰§ç¾ŠçŠ¬"], answer: "çƒ­ç‹—" },
      { question: "ä»€ä¹ˆä¸œè¥¿æœ‰å¤´å´æ²¡æœ‰è„šï¼Ÿ", options: ["äºº", "è›‡", "åºŠ", "é±¼"], answer: "åºŠ" },
      { question: "å°æ˜ä»æ¥¼ä¸Šæ‰ä¸‹æ¥å´æ²¡å—ä¼¤ï¼Œä¸ºä»€ä¹ˆï¼Ÿ", options: ["ä»–æ˜¯æœºå™¨äºº", "ä»–æ‰çš„æ˜¯æ¥¼æ¢¯", "ä»–æ¢¦è§çš„", "ä»–å¤ªèƒ–äº†"], answer: "ä»–æ¢¦è§çš„" },
      { question: "å“ªç§æ°´æœæœ€æ€•å†·ï¼Ÿ", options: ["è¥¿ç“œ", "é¦™è•‰", "æ¢¨", "å†»æŸ¿"], answer: "å†»æŸ¿" },
      { question: "ä»€ä¹ˆåœ°æ–¹å¼€è½¦ä¸ç”¨æ‹…å¿ƒè½¦ç¥¸ï¼Ÿ", options: ["æ“åœº", "æ²™æ¼ ", "åœ°å›¾ä¸Š", "åœè½¦åœº"], answer: "åœ°å›¾ä¸Š" },
      { question: "ä»€ä¹ˆäººæœ€çˆ±è¯´è¯å´ä¸ç®—è¯ï¼Ÿ", options: ["éª—å­", "å“‘å·´", "æ¼”å‘˜", "ä¸»æŒäºº"], answer: "å“‘å·´" },
      { question: "ä»€ä¹ˆä¸œè¥¿å¯ä»¥è·‘å´æ²¡æœ‰è…¿ï¼Ÿ", options: ["è½¦", "å½±å­", "æ°´", "é£"], answer: "æ°´" },
      { question: "å°ç‹çš„çˆ¸çˆ¸æœ‰ä¸‰ä¸ªå„¿å­ï¼šå¤§å„¿å­å«å¤§æ¯›ï¼ŒäºŒå„¿å­å«äºŒæ¯›ï¼Œä¸‰å„¿å­å«ä»€ä¹ˆï¼Ÿ", options: ["å°æ¯›", "ä¸‰æ¯›", "å°ç‹", "æ¯›æ¯›"], answer: "å°ç‹" },
      { question: "å“ªç§ä¹¦æœ€ä¸é è°±ï¼Ÿ", options: ["å°è¯´", "å‚è€ƒä¹¦", "å¤©ä¹¦", "æ¼«ç”»"], answer: "å¤©ä¹¦" },
      { question: "ä»€ä¹ˆé—¨æ°¸è¿œå…³ä¸ä¸Šï¼Ÿ", options: ["è½¦é—¨", "å®¶é—¨", "é“é—¨", "çƒé—¨"], answer: "çƒé—¨" },
      { question: "ä¸ºä»€ä¹ˆç†Šå†¬çœ æ—¶ä¸æ€•å†·ï¼Ÿ", options: ["å› ä¸ºå®ƒæœ‰æ¯›", "èº²åœ¨æ´é‡Œ", "ä¸è§‰å¾—å†·", "å› ä¸ºæ˜¯åŠ¨ç”»é‡Œçš„"], answer: "ä¸è§‰å¾—å†·" },
      { question: "ä»€ä¹ˆä¸œè¥¿è¶Šæ‰”è¶Šå¤§ï¼Ÿ", options: ["çŸ³å¤´", "å½±å­", "æ°”çƒ", "çº¸"], answer: "æ°”çƒ" },
      { question: "å°æ˜çš„å¦ˆå¦ˆæœ‰ä¸‰ä¸ªå„¿å­ï¼Œå¤§å„¿å­å«å¤§æ˜ï¼ŒäºŒå„¿å­å«äºŒæ˜ï¼Œç¬¬ä¸‰ä¸ªå«ä»€ä¹ˆï¼Ÿ", options: ["ä¸‰æ˜", "å°æ˜", "æ˜æ˜", "ä¸æ˜"], answer: "å°æ˜" },
      { question: "å“ªç§é©¬ä¸èƒ½è·‘ï¼Ÿ", options: ["æœ¨é©¬", "ç§é©¬", "èµ›é©¬", "éªé©¬"], answer: "æœ¨é©¬" },
      { question: "ä¸€å¤´ç‰›4æ¡è…¿ï¼Œä¸€åªç¾Š4æ¡è…¿ï¼Œä¸‰åªç¾Šå’Œä¸€å¤´ç‰›ä¸€å…±æœ‰å¤šå°‘æ¡è…¿ï¼Ÿ", options: ["14", "16", "18", "20"], answer: "16" },
      { question: "ä»€ä¹ˆé±¼ä¸ä¼šæ¸¸æ³³ï¼Ÿ", options: ["é²¨é±¼", "é‡‘é±¼", "æ­»é±¼", "ç£é±¼"], answer: "æ­»é±¼" },
      { question: "å“ªä¸€ç§èŠ±æ°¸è¿œä¸å¼€ï¼Ÿ", options: ["ç«ç‘°", "å¤ªé˜³èŠ±", "æ­»èŠ±", "é›èŠ"], answer: "æ­»èŠ±" },
      { question: "ä¸€åªæ‰‹è¡¨æœ€å¤šæœ‰å‡ ä¸ªæŒ‡é’ˆï¼Ÿ", options: ["1ä¸ª", "2ä¸ª", "3ä¸ª", "4ä¸ª"], answer: "3ä¸ª" },
      { question: "å¤ªé˜³ä»å“ªä¸ªæ–¹å‘å‡èµ·ï¼Ÿ", options: ["å—", "åŒ—", "ä¸œ", "è¥¿"], answer: "ä¸œ" },
      { question: "é’Ÿè¡¨åœ¨èµ°åŠ¨æ—¶äººä»¬å¸¸è¯´å®ƒåœ¨â€œèµ°è·¯â€ï¼Œè¿™ç§è¯´æ³•å½¢å®¹çš„æ˜¯ï¼Ÿ", options: ["è·‘æ­¥", "è½¬åœˆ", "èµ°è·¯", "è·³èˆ"], answer: "èµ°è·¯" },
      { question: "ä»€ä¹ˆæ°´æ°¸è¿œç”¨ä¸å®Œï¼Ÿ", options: ["æ²³æ°´", "äº•æ°´", "æµ·æ°´", "æ³ªæ°´"], answer: "æµ·æ°´" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¹°çš„äººçŸ¥é“ï¼Œå–çš„äººçŸ¥é“ï¼Œåªæœ‰ç”¨çš„äººä¸çŸ¥é“ï¼Ÿ", options: ["è¯", "æ£ºæ", "çƒŸ", "é‹"], answer: "æ£ºæ" },
      { question: "å“ªä¸€ç§å­—äººäººè§äº†éƒ½ä¼šå¿µé”™ï¼Ÿ", options: ["è°œ", "éš¾", "é”™", "ä¸ä¼š"], answer: "é”™" },
      { question: "æœ‰ä¸€ç§é¸Ÿä¸ä¼šé£ï¼Œå®ƒæ˜¯ä»€ä¹ˆï¼Ÿ", options: ["ä¼é¹…", "é¸µé¸Ÿ", "é¸¡", "é¸­"], answer: "ä¼é¹…" },
      { question: "ä»€ä¹ˆæ¯å­ä¸èƒ½è£…æ°´ï¼Ÿ", options: ["èŒ¶æ¯", "é…’æ¯", "æ¸©åº¦è®¡", "å¡‘æ–™æ¯"], answer: "æ¸©åº¦è®¡" },
      { question: "ä»€ä¹ˆæ ·çš„è·¯ä¸èƒ½èµ°ï¼Ÿ", options: ["ç¡¬è·¯", "ç”°å­—è·¯", "äººè¡Œé“", "æ£‹ç›˜è·¯"], answer: "æ£‹ç›˜è·¯" },
      { question: "ä¸€ä¸ªäººè¿ç»­è·³äº†10æ¬¡ï¼Œæœ€åè¿˜ç«™åœ¨åŸåœ°ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆï¼Ÿ", options: ["ä»–åœ¨åŸåœ°è·³", "ä»–æ²¡åŠ¨", "ä»–è·³çš„æ˜¯åŸåœ°è·³", "ä»–åœ¨æ‰“è½¬"], answer: "ä»–åœ¨åŸåœ°è·³" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ‰“ç¢äº†äººä»¬ä¸ä¼šå“­ï¼Ÿ", options: ["ç»ç’ƒ", "å¿ƒ", "è›‹", "ç³–"], answer: "è›‹" },
      { question: "å“ªç§é—¨æ°¸è¿œæ‰“ä¸å¼€ï¼Ÿ", options: ["ç³–é—¨", "æœ¨é—¨", "ç”µè„‘é—¨", "è™šæ‹Ÿé—¨"], answer: "è™šæ‹Ÿé—¨" },
      { question: "æœ‰ä¸ªäººä¸€å¹´åªå·¥ä½œä¸€å¤©ï¼ŒçŒœæ˜¯å“ªä¸ªèŠ‚æ—¥ï¼Ÿ", options: ["æ˜¥èŠ‚", "å›½åº†", "æ„šäººèŠ‚", "åŠ³åŠ¨èŠ‚"], answer: "æ„šäººèŠ‚" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä½ æƒ³æ‰“ç ´å®ƒï¼Œå´ä¸èƒ½çœŸæ­£æ‰“ç ´ï¼Ÿ", options: ["é“", "ç»ç’ƒ", "æ²‰é»˜", "æ ‘æ"], answer: "æ²‰é»˜" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä»æ¥ä¸ä¼šè¯´è°ï¼Ÿ", options: ["é•œå­", "é’Ÿ", "ä¹¦", "é›¨"], answer: "é•œå­" },
      { question: "å°ææŠŠä¸€é¢—æ˜Ÿæ˜Ÿæ‘˜ä¸‹æ¥è£…è¿›å£è¢‹ï¼Œä¸ºä»€ä¹ˆï¼Ÿ", options: ["ä»–æ˜¯é­”æ³•å¸ˆ", "å¤©é»‘å‰", "åªæ˜¯æ¯”å–»", "å› ä¸ºæœ‰å¤œæ˜ç "], answer: "åªæ˜¯æ¯”å–»" },
      { question: "å“ªç§æ¯å­æ°¸è¿œä¹Ÿå–ä¸åˆ°æ°´ï¼Ÿ", options: ["èŒ¶æ¯", "å’–å•¡æ¯", "å† å†›æ¯", "å¡‘æ–™æ¯"], answer: "å† å†›æ¯" },
      { question: "ä»€ä¹ˆä¸œè¥¿è¶Šè—è¶Šå¤šï¼Ÿ", options: ["é’±", "ç§˜å¯†", "é—®é¢˜", "è°è¨€"], answer: "è°è¨€" },
      { question: "å“ªç§åŠ¨ç‰©æœ€å–œæ¬¢è‡ªæ‹ï¼Ÿ", options: ["çŒ´å­", "å¤§è±¡", "è¢‹é¼ ", "æ–‘é©¬"], answer: "çŒ´å­" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¹°çš„äººçŸ¥é“ï¼Œå–çš„äººçŸ¥é“ï¼Œç”¨çš„äººå´ä¸çŸ¥é“ï¼Ÿ", options: ["æ‰‹æœº", "æ£ºæ", "ä¹¦", "è½¦"], answer: "æ£ºæ" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ²¡äººè§è¿‡ï¼Œå´å­˜åœ¨ï¼Ÿ", options: ["å¹½çµ", "æœªæ¥", "æƒ³è±¡", "ç©ºæ°”"], answer: "æœªæ¥" },
      { question: "ä»€ä¹ˆä¸œè¥¿èƒ½è®©äººçœ‹è§åˆ«äººï¼Œå´çœ‹ä¸è§è‡ªå·±ï¼Ÿ", options: ["çœ¼ç›", "ç…§ç‰‡", "é•œå­", "å½±å­"], answer: "é•œå­" },
      { question: "å“ªç§ä¹¦æœ¬æ‰“å¼€åæ²¡æœ‰çº¸ï¼Ÿ", options: ["å°è¯´", "ç”µå­ä¹¦", "ç©ºç™½ä¹¦", "å­—å…¸"], answer: "ç”µå­ä¹¦" },
      { question: "ä»€ä¹ˆä¸œè¥¿åˆ°äº†æ™šä¸Šæ¯”ç™½å¤©é«˜ï¼Ÿ", options: ["å½±å­", "æ¸©åº¦", "æ˜Ÿæ˜Ÿ", "æœˆäº®"], answer: "å½±å­" },
      { question: "ä»€ä¹ˆæ ·çš„æ‰‹æ°¸è¿œæŠ“ä¸åˆ°ä¸œè¥¿ï¼Ÿ", options: ["ç©ºæ‰‹", "å½±å­", "å‡æ‰‹", "å¤§æ‰‹"], answer: "å½±å­" },
      { question: "ä»€ä¹ˆä¸œè¥¿è¶Šç”¨è¶Šå¤šï¼Œè¶Šä¸ç”¨è¶Šå°‘ï¼Ÿ", options: ["é’±", "é£Ÿç‰©", "çŸ¥è¯†", "ç»éªŒ"], answer: "çŸ¥è¯†" },
      { question: "ä¸€ä¸ªäººèº«ä¸Šæœ‰å››ä¸ªè§’ï¼Œæ˜¯ä»€ä¹ˆäººï¼Ÿ", options: ["è­¦å¯Ÿ", "ç–¯å­", "å›¾çº¸ä¸Šçš„äºº", "ç”»ä¸­äºº"], answer: "å›¾çº¸ä¸Šçš„äºº" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ°¸è¿œä¸ä¼šè¢«è„šè¸¢æ‰ï¼Ÿ", options: ["è¶³çƒ", "å½±å­", "æ°”çƒ", "äº‘"], answer: "å½±å­" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¸ç®¡ç”¨å¤šä¹…éƒ½ä¸ä¼šè¿‡æœŸï¼Ÿ", options: ["ç‰›å¥¶", "æ‰‹æœº", "çŸ¥è¯†", "æ°´æœ"], answer: "çŸ¥è¯†" },
      { question: "æ¡Œå­ä¸Šæœ‰å››ä¸ªè‹¹æœï¼Œä½ æ‹¿èµ°ä¸€ä¸ªï¼Œè¿˜å‰©å‡ ä¸ªï¼Ÿ", options: ["3", "4", "5", "0"], answer: "4" },
      { question: "ä»€ä¹ˆé’¥åŒ™æ‰“ä¸å¼€é—¨ï¼Ÿ", options: ["é”åŒ™", "ç´é”®", "è½¦åŒ™", "æˆ¿åŒ™"], answer: "ç´é”®" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ€»æ˜¯åœ¨ä½ å‰é¢ï¼Œå´æ°¸è¿œçœ‹ä¸è§ï¼Ÿ", options: ["æœªæ¥", "å½±å­", "é“è·¯", "æ¢¦æƒ³"], answer: "æœªæ¥" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ”¾åœ¨å£è¢‹é‡Œï¼Œè¶Šæ‹¿è¶Šè½»ï¼Ÿ", options: ["é’±", "çŸ³å¤´", "ç©º", "ç¾½æ¯›"], answer: "ç©º" },
      { question: "æœ‰ä¸ªäººä»é£æœºä¸Šè·³ä¸‹å´æ²¡æœ‰å—ä¼¤ï¼Œä¸ºä»€ä¹ˆï¼Ÿ", options: ["ä»–å¼€ä¼äº†", "ä»–åªæ˜¯è·³æ¢¦é‡Œ", "ä»–åœ¨æ¢¦é‡Œ", "ä»–æ˜¯è¶…äºº"], answer: "ä»–åœ¨æ¢¦é‡Œ" },
      { question: "ä»€ä¹ˆä¹¦æ°¸è¿œæ²¡äººè¯»ï¼Ÿ", options: ["å°è¯´", "å°å†", "æ—¥è®°", "ä¼‘é—²ä¹¦"], answer: "å°å†" },
      { question: "ä»€ä¹ˆæ ·çš„æ¡Œå­æ°¸è¿œåœ¨è½¬ï¼Ÿ", options: ["è½¬æ¡Œ", "æ™ƒæ¡Œ", "æ‘‡æ¡Œ", "é£æ¡Œ"], answer: "è½¬æ¡Œ" },
      { question: "å“ªç§æ‰‹æœºæ°¸è¿œä¸ä¼šå“ï¼Ÿ", options: ["æ™ºèƒ½æ‰‹æœº", "æ—§æ‰‹æœº", "åæ‰‹æœº", "æ¨¡å‹æ‰‹æœº"], answer: "æ¨¡å‹æ‰‹æœº" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¸€æ—¦è¯´å‡ºå£å°±ä¼šæ¶ˆå¤±ï¼Ÿ", options: ["ç§˜å¯†", "æ²‰é»˜", "ç©ºæ°”", "ç¬‘å£°"], answer: "æ²‰é»˜" },
      { question: "ä»€ä¹ˆè½¦æ²¡æœ‰è½®å­ä¹Ÿèƒ½è·‘ï¼Ÿ", options: ["ç©å…·è½¦", "æ€ç»´è½¦", "æ¢¦ä¸­è½¦", "é£è½¦"], answer: "é£è½¦" },
      { question: "é£æœºé£è¡Œæ—¶æœ€æ€•é‡åˆ°ä»€ä¹ˆï¼Ÿ", options: ["å°é¸Ÿ", "é£", "é›·", "é›¾"], answer: "é›¾" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¸€è¯´å‡ºæ¥å°±ä¼šæ¶ˆå¤±ï¼Ÿ", options: ["ç§˜å¯†", "æ²‰é»˜", "æ—¶é—´", "å›å£°"], answer: "æ²‰é»˜" },
      { question: "ä»€ä¹ˆåŠ¨ç‰©æœ€æ“…é•¿è¡¨æ¼”ï¼Ÿ", options: ["çŒ´å­", "ç‹—", "çŒ«", "é±¼"], answer: "çŒ´å­" },
      { question: "å“ªä¸ªå­—æ°¸è¿œå†™ä¸å¯¹ï¼Ÿ", options: ["é”™", "å¯¹", "çˆ±", "å¥½"], answer: "é”™" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä½ æ˜çŸ¥é“ä¸æ˜¯çœŸçš„ï¼Œå´è¿˜å¸¸å¸¸çœ‹åˆ°ï¼Ÿ", options: ["æ¢¦", "å¹»å½±", "å½±å­", "å½±åƒ"], answer: "å¹»å½±" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ¯”å¤©è¿˜é«˜ï¼Ÿ", options: ["å±±", "äº‘", "æ¥¼", "æ¢¦æƒ³"], answer: "æ¢¦æƒ³" },
      { question: "å“ªç§é±¼æœ€ä¼šè·³èˆï¼Ÿ", options: ["è·³é±¼", "é‡‘é±¼", "æµ·é©¬", "é²¨é±¼"], answer: "è·³é±¼" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¸ä¼šæ‰æ¯›ï¼Ÿ", options: ["çŒ«", "å…”å­", "äºº", "å…‰å¤´"], answer: "å…‰å¤´" },
      { question: "å“ªä¸ªæœˆæ˜¯æ‰€æœ‰æœˆä»½ä¸­æœ€çŸ­çš„ï¼Ÿ", options: ["ä¸€æœˆ", "äºŒæœˆ", "ä¸‰æœˆ", "å››æœˆ"], answer: "äºŒæœˆ" },
      { question: "ä»€ä¹ˆä¸œè¥¿è¶Šåˆ†è¶Šå¤šï¼Ÿ", options: ["é’±", "è›‹ç³•", "æƒ…æ„Ÿ", "ç¬‘å®¹"], answer: "ç¬‘å®¹" },
      { question: "ä»€ä¹ˆåŠ¨ç‰©æœ€çˆ±é€›è¶…å¸‚ï¼Ÿ", options: ["ç‹—", "çŒ«", "ç†Š", "çŒ´å­"], answer: "ç†Š" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ°¸è¿œä¸ä¼šè¯´è¯ï¼Ÿ", options: ["ä¹¦", "å½±å­", "çŸ³å¤´", "é’Ÿè¡¨"], answer: "çŸ³å¤´" },
      { question: "æœ‰ä¸€ç§è½¦æ°¸è¿œä¸éœ€è¦åŠ æ²¹ï¼Œè¿™æ˜¯ä»€ä¹ˆè½¦ï¼Ÿ", options: ["ç”µåŠ¨è½¦", "è‡ªè¡Œè½¦", "ç©å…·è½¦", "é£è½¦"], answer: "è‡ªè¡Œè½¦" },
      { question: "å“ªç§é—¨ä»æ¥éƒ½æ‰“ä¸å¼€ï¼Ÿ", options: ["æ ¡é—¨", "æˆ¿é—¨", "å¤©é—¨", "å›´æ£‹é—¨"], answer: "å¤©é—¨" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ˜æ˜æ˜¯ç»¿è‰²çš„ï¼Œå´çœ‹ä¸è§ï¼Ÿ", options: ["æ ‘", "å¶å­", "éšå½¢ç»¿", "ä¸è§çš„ç»¿"], answer: "éšå½¢ç»¿" },
      { question: "ä»€ä¹ˆä¸œè¥¿åœ¨ä½ è§¦ç¢°æ—¶ä¼šç ´è£‚ï¼Ÿ", options: ["è›‹", "æ°”çƒ", "çº¸", "æ°´"], answer: "æ°”çƒ" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ˜¯ç”¨æ¥ç»™åˆ«äººçœ‹çš„ï¼Œå´æ°¸è¿œçœ‹ä¸è§è‡ªå·±çš„ï¼Ÿ", options: ["é•œå­", "ç…§ç‰‡", "çœ¼ç›", "ç”»"], answer: "é•œå­" },
      { question: "å“ªç§ä¹¦æ‰“å¼€åæ²¡æœ‰çº¸ï¼Ÿ", options: ["å°è¯´", "ç”µå­ä¹¦", "ç©ºç™½ä¹¦", "æ—¥è®°"], answer: "ç”µå­ä¹¦" },
      { question: "ä»€ä¹ˆä¸œè¥¿æ¯å¤©éƒ½åœ¨å¢åŠ ï¼Œä½†ç”¨çš„æ—¶å€™å´å˜å°‘ï¼Ÿ", options: ["çƒ¦æ¼", "é—®é¢˜", "å¹´é¾„", "å›å¿†"], answer: "é—®é¢˜" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¸€æ—¦å¤±å»äº†å°±å†ä¹Ÿæ‰¾ä¸å›æ¥ï¼Ÿ", options: ["æ—¶é—´", "é‡‘é’±", "é’æ˜¥", "æœºä¼š"], answer: "æ—¶é—´" },
      { question: "å“ªç§åŠ¨ç‰©å¼€ä¼šæœ€æœ‰æ•ˆç‡ï¼Ÿ", options: ["ç‹®å­", "èš‚èš", "èœœèœ‚", "ä¹Œé¾Ÿ"], answer: "èœœèœ‚" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¸åƒé¥­ä¹Ÿèƒ½æ´»ï¼Ÿ", options: ["äºº", "æ¤ç‰©", "åŠ¨ç‰©", "é±¼"], answer: "æ¤ç‰©" },
      { question: "ä»€ä¹ˆé’Ÿæ°¸è¿œä¸ä¼šè¿Ÿåˆ°ï¼Ÿ", options: ["é—¹é’Ÿ", "æ‰‹è¡¨", "æŒ‚é’Ÿ", "ç”µé’Ÿ"], answer: "é—¹é’Ÿ" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¹°äº†ä»¥åæ‰ä¼šçŸ¥é“çœŸç›¸ï¼Ÿ", options: ["æŠ½å¥–", "ä¿é™©", "è°è¨€", "è½®èƒ"], answer: "è°è¨€" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¸€æå°±è®©äººå¿˜è®°çƒ¦æ¼ï¼Ÿ", options: ["ç¬‘", "æ³ª", "æ€’", "å¿™"], answer: "ç¬‘" },
      { question: "ä»€ä¹ˆä¸œè¥¿è¶Šèº²è¶Šæ˜¾çœ¼ï¼Ÿ", options: ["ç§˜å¯†", "è°è¨€", "å½±å­", "ç¬‘å®¹"], answer: "è°è¨€" },
      { question: "ä»€ä¹ˆä¸œè¥¿ä¸€æ—¦å¤±å»å°±æ°¸è¿œå›ä¸æ¥äº†ï¼Ÿ", options: ["é‡‘é’±", "æ—¶é—´", "çˆ±æƒ…", "é’æ˜¥"], answer: "æ—¶é—´" }
    ];

    // å¤šæ–‡ä»¶æ”¯æŒ - é¢„å®šä¹‰çš„å•è¯åº“æ–‡ä»¶å
    const predefinedWordFiles = [
      {id: "two", name: "äºŒå¹´çº§å•è¯", filename: "two_words.txt"},
      {id: "basic", name: "æ–°æ¦‚å¿µ1è¯åº“", filename: "basic_words.txt"},
    ];

    // å¸¸è§å‘éŸ³å˜ä½“æ˜ å°„
    const pronunciationVariants = {
      "morning": ["mornin", "mornning"],
      "afternoon": ["afternun", "afternooon"],
      "evening": ["evenin", "evenning"],
      "night": ["nite", "nigh"],
      "fine": ["fyn", "faine"],
      "thank": ["thang", "thankyou"],
      "goodbye": ["goodby", "bye"],
      "day": ["dai", "dae"],
      "today": ["toda", "taday"]
    };

    // å•è¯æ–‡ä»¶å­˜å‚¨
    let wordFiles = {
      "default": { name: "é»˜è®¤å•è¯åº“", words: defaultWordList, isCustom: false }
    };
    let currentFile = "default";

    // æ¸¸æˆå˜é‡ - ä»æœ¬åœ°å­˜å‚¨åŠ è½½æˆ–åˆå§‹åŒ–
    let gameData = JSON.parse(localStorage.getItem('wordGameData')) || {
      currentIndex: 0,
      level: 0,
      correctCount: 0,
      wrongList: [],
      levelStars: [],
      puzzleQuestionsUsed: []
    };

    // åŒæ­¥å˜é‡åˆ°å†…å­˜
    let currentIndex = gameData.currentIndex;
    let level = gameData.level;
    let inPuzzle = false;
    let correctCount = gameData.correctCount;
    let wrongList = gameData.wrongList;
    let isReviewMode = false;
    let currentStreak = 0;
    let levelStars = gameData.levelStars;
    let currentReviewIndex = 0;
    let levelCorrect = 0;
    let recognition; // è¯­éŸ³è¯†åˆ«å¯¹è±¡
    let isListening = false; // æ–°å¢ï¼šè·Ÿè¸ªè¯­éŸ³è¯†åˆ«çŠ¶æ€

    // æ ‡è®°å·²ä½¿ç”¨çš„è°œé¢˜
    puzzleQuestions.forEach(q => {
      if (gameData.puzzleQuestionsUsed.includes(puzzleQuestions.indexOf(q))) {
        q.used = true;
      }
    });

    const instructionEl = document.getElementById("instruction");
    const questionEl = document.getElementById("question");
    const resultEl = document.getElementById("result");
    const optionsEl = document.getElementById("options");
    const definitionEl = document.getElementById("definition");
    const phoneticEl = document.getElementById("phonetic");
    const letterBox = document.getElementById("letterBox");
    const statsEl = document.getElementById("stats");
    const nextBtn = document.getElementById("nextBtn");
    const prevBtn = document.getElementById("prevBtn");
    const startReadingBtn = document.getElementById("startReadingBtn");
    const deleteFileBtn = document.getElementById("deleteFileBtn");
    const fileNotification = document.getElementById("fileNotification");
    const similarityMeter = document.getElementById("similarityMeter");
    const similarityFill = document.getElementById("similarityFill");

    const correctSound = document.getElementById("correct-sound");
    const wrongSound = document.getElementById("wrong-sound");

    // åˆå§‹åŒ–æ–‡ä»¶é€‰æ‹©å™¨
    function initFileSelector() {
      const selectEl = document.getElementById("wordFileSelect");
      const fileProgress = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
      
      // æ¸…ç©ºç°æœ‰é€‰é¡¹ï¼ˆä¿ç•™é»˜è®¤é€‰é¡¹ï¼‰
      const defaultOption = selectEl.querySelector('option[value="default"]');
      selectEl.innerHTML = '';
      selectEl.appendChild(defaultOption);
      
      // åˆ›å»ºä¸€ä¸ªé›†åˆæ¥è·Ÿè¸ªå·²æ·»åŠ çš„é€‰é¡¹å€¼
      const addedOptions = new Set(['default']);
      
      // æ·»åŠ é¢„å®šä¹‰çš„å•è¯åº“æ–‡ä»¶é€‰é¡¹
      predefinedWordFiles.forEach(file => {
        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²åŠ è½½è¿‡
        if (!wordFiles[file.id]) {
          wordFiles[file.id] = {
            name: file.name,
            filename: file.filename,
            words: [],
            isCustom: true,
            loaded: false
          };
        }
        
        // åªæ·»åŠ ä¸å­˜åœ¨çš„é€‰é¡¹
        if (!addedOptions.has(file.id)) {
          const option = document.createElement("option");
          option.value = file.id;
          option.textContent = file.name;
          selectEl.appendChild(option);
          addedOptions.add(file.id);
        }
      });
      
      // ä»æœ¬åœ°å­˜å‚¨åŠ è½½è‡ªå®šä¹‰æ–‡ä»¶è¿›åº¦
      const savedFiles = JSON.parse(localStorage.getItem('customWordFiles') || '{}');
      Object.keys(savedFiles).forEach(key => {
        if (!wordFiles[key]) {
          wordFiles[key] = savedFiles[key];
        }
        
        // åªæ·»åŠ ä¸å­˜åœ¨çš„é€‰é¡¹
        if (!addedOptions.has(key)) {
          const option = document.createElement("option");
          option.value = key;
          option.textContent = wordFiles[key].name;
          selectEl.appendChild(option);
          addedOptions.add(key);
        }
      });
      
      // æ¢å¤å½“å‰é€‰ä¸­çš„æ–‡ä»¶
      selectEl.value = currentFile;
      
      // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
      updateDeleteButton();
    }

    // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
    function updateDeleteButton() {
      deleteFileBtn.disabled = currentFile === "default";
      deleteFileBtn.style.display = currentFile === "default" ? "none" : "inline-block";
    }

    // åŠ è½½é€‰ä¸­çš„å•è¯æ–‡ä»¶
    function loadSelectedWordFile() {
      const selectedFile = document.getElementById("wordFileSelect").value;
      if (selectedFile && wordFiles[selectedFile] && selectedFile !== currentFile) {
        // ä¿å­˜å½“å‰æ–‡ä»¶çš„è¿›åº¦
        saveCurrentFileProgress();
        
        // åˆ‡æ¢åˆ°é€‰ä¸­æ–‡ä»¶
        currentFile = selectedFile;
        fileNotification.textContent = "";
        
        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦éœ€è¦åŠ è½½
        const file = wordFiles[currentFile];
        if (!file.loaded && file.filename) {
          loadWordFileFromServer(file);
          return;
        }
        
        // åŠ è½½æ–‡ä»¶è¿›åº¦
        loadFileProgress();
        isReviewMode = false;
        
        // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
        updateDeleteButton();
        
        loadNext();
      }
    }

    // ä»æœåŠ¡å™¨/æœ¬åœ°åŠ è½½å•è¯æ–‡ä»¶
    function loadWordFileFromServer(file) {
      fileNotification.textContent = `æ­£åœ¨åŠ è½½ ${file.name}...`;
      
      // åˆ›å»ºä¸€ä¸ªæ–°çš„XMLHttpRequest
      const xhr = new XMLHttpRequest();
      xhr.open('GET', file.filename, true);
      
      xhr.onload = function() {
        if (xhr.status === 200) {
          try {
            // è§£æTXTæ–‡ä»¶å†…å®¹ï¼ˆæ¯è¡Œä¸€ä¸ªå•è¯å’Œé‡Šä¹‰ï¼Œç”¨é€—å·åˆ†éš”ï¼‰
            const content = xhr.responseText;
            const words = [];
            const lines = content.split('\n');
            
            lines.forEach(line => {
              if (line.trim()) {
                const [word, definition, phonetic] = line.split(',');
                if (word && definition) {
                  words.push({ 
                    word: word.trim(), 
                    definition: definition.trim(),
                    phonetic: phonetic ? phonetic.trim() : 'æ— éŸ³æ ‡'
                  });
                }
              }
            });
            
            if (words.length > 0) {
              // æ›´æ–°å•è¯æ–‡ä»¶æ•°æ®
              file.words = words;
              file.loaded = true;
              
              // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
              const savedFiles = JSON.parse(localStorage.getItem('customWordFiles') || '{}');
              savedFiles[file.id] = {
                name: file.name,
                filename: file.filename,
                words: words,
                isCustom: true,
                loaded: true
              };
              localStorage.setItem('customWordFiles', JSON.stringify(savedFiles));
              
              fileNotification.textContent = `${file.name} åŠ è½½æˆåŠŸï¼å…± ${words.length} ä¸ªå•è¯ã€‚`;
              
              // åŠ è½½æ–‡ä»¶è¿›åº¦
              loadFileProgress();
              // ä¿æŒå½“å‰å•è¯ç´¢å¼•ä¸å˜
              currentIndex = currentIndex; 
              isReviewMode = false;
              
              // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
              updateDeleteButton();
              
              loadNext();
            } else {
              fileNotification.textContent = `é”™è¯¯ï¼š${file.name} æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ç¡®ä¿æ¯è¡ŒåŒ…å«ä¸€ä¸ªå•è¯å’Œé‡Šä¹‰ï¼Œç”¨é€—å·åˆ†éš”ã€‚`;
            }
          } catch (error) {
            console.error("è§£ææ–‡ä»¶é”™è¯¯:", error);
            fileNotification.textContent = `é”™è¯¯ï¼šæ— æ³•è§£æ ${file.name}ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚`;
          }
        } else if (xhr.status === 404) {
          fileNotification.textContent = `é”™è¯¯ï¼šæœªæ‰¾åˆ° ${file.name}ï¼ˆ${file.filename}ï¼‰ï¼Œè¯·ç¡®ä¿æ–‡ä»¶å·²æ”¾åœ¨ä¸HTMLç›¸åŒçš„ç›®å½•ä¸‹ã€‚`;
        } else {
          fileNotification.textContent = `é”™è¯¯ï¼šåŠ è½½ ${file.name} å¤±è´¥ï¼ŒçŠ¶æ€ç : ${xhr.status}`;
        }
      }
      
      xhr.onerror = function() {
        fileNotification.textContent = `é”™è¯¯ï¼šåŠ è½½ ${file.name} å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚`;
      }
      
      xhr.send();
    }

    // ä¿å­˜å½“å‰æ–‡ä»¶çš„è¿›åº¦
    function saveCurrentFileProgress() {
      const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
      progressData[currentFile] = {
        currentIndex,
        level,
        correctCount,
        wrongList,
        levelStars,
        puzzleQuestionsUsed: puzzleQuestions
          .map((q, i) => q.used ? i : null)
          .filter(i => i !== null)
      };
      localStorage.setItem('wordFileProgress', JSON.stringify(progressData));
    }

    // åŠ è½½æ–‡ä»¶çš„è¿›åº¦
    function loadFileProgress() {
      const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
      const fileProgress = progressData[currentFile] || {};
      
      // åº”ç”¨æ–‡ä»¶ç‰¹å®šçš„è¿›åº¦æ•°æ®
      currentIndex = fileProgress.currentIndex || 0;
      level = fileProgress.level || 0;
      correctCount = fileProgress.correctCount || 0;
      wrongList = fileProgress.wrongList || [];
      levelStars = fileProgress.levelStars || [];
      
      if (fileProgress.puzzleQuestionsUsed) {
        puzzleQuestions.forEach((q, i) => {
          q.used = fileProgress.puzzleQuestionsUsed.includes(i);
        });
      }
    }

    // é¡µé¢å…³é—­æˆ–åˆ·æ–°æ—¶ä¿å­˜è¿›åº¦
    window.addEventListener('beforeunload', function() {
      saveCurrentFileProgress();
    });

    // åˆ é™¤å½“å‰æ–‡ä»¶çš„è¿›åº¦æ•°æ®
    function deleteCurrentFile() {
      if (currentFile === "default") {
        alert("é»˜è®¤å•è¯åº“ä¸èƒ½åˆ é™¤");
        return;
      }
      
      if (confirm(`ç¡®å®šè¦åˆ é™¤"${wordFiles[currentFile].name}"çš„è¿›åº¦æ•°æ®å—ï¼Ÿ`)) {
        // åˆ é™¤è¿›åº¦æ•°æ®
        const progressData = JSON.parse(localStorage.getItem('wordFileProgress') || '{}');
        delete progressData[currentFile];
        localStorage.setItem('wordFileProgress', JSON.stringify(progressData));
        
        // é‡æ–°åŠ è½½è¿›åº¦
        loadFileProgress();
        isReviewMode = false;
        
        loadNext();
      }
    }

    // ä¿å­˜æ¸¸æˆè¿›åº¦åˆ°æœ¬åœ°å­˜å‚¨
    function saveProgress() {
      // æ›´æ–°æ¸¸æˆæ•°æ®
      gameData.currentIndex = currentIndex;
      gameData.level = level;
      gameData.correctCount = correctCount;
      gameData.wrongList = wrongList;
      gameData.levelStars = levelStars;
      gameData.puzzleQuestionsUsed = puzzleQuestions
        .map((q, i) => q.used ? i : null)
        .filter(i => i !== null);
      
      // ä¿å­˜åˆ°å½“å‰æ–‡ä»¶çš„è¿›åº¦ä¸­
      saveCurrentFileProgress();
    }

    function updateStats() {
      const currentWords = wordFiles[currentFile].words;
      statsEl.innerHTML = `
        <div class="stat-item"><i class="fa fa-check-circle text-secondary mr-1"></i> æ­£ç¡®ï¼š<span class="stat-value">${correctCount}</span></div>
        <div class="stat-item"><i class="fa fa-times-circle text-danger mr-1"></i> é”™è¯¯ï¼š<span class="stat-value">${wrongList.length}</span></div>
        <div class="stat-item"><i class="fa fa-book text-primary mr-1"></i> è¿›åº¦ï¼š<span class="stat-value">${currentIndex + 1} / ${currentWords.length}</span></div>
      `;
    }

    function loadNext() {
      resultEl.textContent = "";
      optionsEl.innerHTML = "";
      letterBox.innerHTML = "";
      similarityMeter.style.display = "none"; // éšè—ç›¸ä¼¼åº¦æŒ‡ç¤ºå™¨
      updateStats();
      startReadingBtn.style.display = "none";
      // é‡ç½®è¯­éŸ³è¯†åˆ«çŠ¶æ€
      isListening = false;
      startReadingBtn.textContent = "å¼€å§‹æœ—è¯»";
      startReadingBtn.classList.remove("listening");
      
      // ç¡®ä¿è·³è¿‡æŒ‰é’®å§‹ç»ˆæ˜¾ç¤º
      nextBtn.style.display = "inline-block";
      nextBtn.disabled = false;
      nextBtn.textContent = isReviewMode ? "ä¸‹ä¸€ä¸ªé”™é¢˜" : "è·³è¿‡æ­¤é¢˜";
      
      // æ›´æ–°ä¸Šä¸€é¢˜æŒ‰é’®çŠ¶æ€
      if (isReviewMode) {
        prevBtn.disabled = currentReviewIndex <= 0;
      } else {
        prevBtn.disabled = currentIndex <= 0;
      }

      // é”™é¢˜å›é¡¾æ¨¡å¼
      if (isReviewMode) {
        document.querySelector('button[onclick="exitReview()"]').style.display = "inline-block";
        // ç©ºé”™é¢˜æœ¬çš„æç¤º
        if (wrongList.length === 0) {
          instructionEl.textContent = "ğŸ‰ æ­å–œä½ æ”»å…‹äº†æ‰€æœ‰é”™é¢˜ï¼";
          definitionEl.textContent = "ç»§ç»­åŠ æ²¹å“¦ï¼";
          phoneticEl.textContent = "";
          questionEl.textContent = "";
          nextBtn.style.display = "none";
          prevBtn.style.display = "none";
          return;
        }
        // ç¡®ä¿ç´¢å¼•åœ¨æœ‰æ•ˆèŒƒå›´å†…
        if (currentReviewIndex >= wrongList.length) {
          currentReviewIndex = 0;
        }
        const wordObj = wrongList[currentReviewIndex];
        instructionEl.innerHTML = `<span class="level-badge">é”™é¢˜å›é¡¾</span> ç¬¬ ${currentReviewIndex + 1}/${wrongList.length} é¢˜`;
        definitionEl.textContent = `ä¸­æ–‡æç¤ºï¼š${wordObj.definition}`;
        phoneticEl.textContent = `éŸ³æ ‡ï¼š${wordObj.phonetic || 'æ— '}`;
        questionEl.textContent = "è¯·è¡¥å…¨å•è¯ï¼š";
        
        // ç”Ÿæˆè¾“å…¥æ¡†ï¼ˆé¦–å­—æ¯å›ºå®šï¼‰
        const first = document.createElement("input");
        first.type = "text";
        first.maxLength = 1;
        first.className = "fixed-letter";
        first.value = wordObj.word[0];
        first.readOnly = true;
        letterBox.appendChild(first);

        for (let i = 1; i < wordObj.word.length; i++) {
          const input = document.createElement("input");
          input.type = "text";
          input.maxLength = 1;
          input.className = "letter-input";
          input.dataset.index = i;
          addInputListeners(input);
          letterBox.appendChild(input);
        }
        letterBox.querySelector("input.letter-input")?.focus();
        
        // è‡ªåŠ¨æ’­æ”¾å½“å‰å•è¯è¯»éŸ³
        setTimeout(() => readWord(), 500);
        return;
      }

      // æ­£å¸¸é—¯å…³æ¨¡å¼
      document.querySelector('button[onclick="exitReview()"]').style.display = "none";
      const start = level * 8;
      if (currentIndex - start >= 8) {
        showPuzzle();
        return;
      }
      if (currentIndex >= wordFiles[currentFile].words.length) {
        instructionEl.textContent = "ğŸ‰ æ­å–œä½ å®Œæˆæ‰€æœ‰å•è¯ï¼";
        definitionEl.innerHTML = `æ€»æ˜Ÿçº§ï¼š${levelStars.reduce((a, b) => a + b, 0)}/${levelStars.length * 3} â­`;
        phoneticEl.textContent = "";
        questionEl.textContent = "";
        nextBtn.style.display = "none";
        prevBtn.style.display = "none";
        return;
      }

      const currentWords = wordFiles[currentFile].words;
      const wordObj = currentWords[currentIndex];
      instructionEl.innerHTML = `<span class="level-badge">ç¬¬ ${level + 1} å…³</span> ç¬¬ ${currentIndex - start + 1}/${Math.min(8, currentWords.length - start)} é¢˜`;
      definitionEl.textContent = `ä¸­æ–‡æç¤ºï¼š${wordObj.definition}`;
      phoneticEl.textContent = `éŸ³æ ‡ï¼š${wordObj.phonetic || 'æ— '}`;
      questionEl.textContent = "è¯·è¡¥å…¨å•è¯ï¼š";

      // ç”Ÿæˆè¾“å…¥æ¡†ï¼ˆé¦–å­—æ¯å›ºå®šï¼‰
      const first = document.createElement("input");
      first.type = "text";
      first.maxLength = 1;
      first.className = "fixed-letter";
      first.value = wordObj.word[0];
      first.readOnly = true;
      letterBox.appendChild(first);

      for (let i = 1; i < wordObj.word.length; i++) {
        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 1;
        input.className = "letter-input";
        input.dataset.index = i;
        addInputListeners(input);
        letterBox.appendChild(input);
      }
      letterBox.querySelector("input.letter-input")?.focus();
      
      // è‡ªåŠ¨æ’­æ”¾å½“å‰å•è¯è¯»éŸ³
      setTimeout(() => readWord(), 500);
      return;
    }

    // ä¸Šä¸€é¢˜åŠŸèƒ½
    function prevQuestion() {
      if (isReviewMode) {
        // å¤ä¹ æ¨¡å¼ï¼šè¿”å›åˆ°ä¸Šä¸€ä¸ªé”™é¢˜
        if (currentReviewIndex > 0) {
          currentReviewIndex--;
          loadNext();
        }
        return;
      }
      
      // æ­£å¸¸é—¯å…³æ¨¡å¼ï¼šè¿”å›åˆ°ä¸Šä¸€ä¸ªå•è¯
      if (currentIndex > 0) {
        // æ£€æŸ¥å½“å‰å•è¯æ˜¯å¦å·²è¢«æ ‡è®°ä¸ºé”™è¯¯
        const currentWords = wordFiles[currentFile].words;
        const currentWord = currentWords[currentIndex];
        const isAlreadyInWrong = wrongList.some(item => item.word === currentWord.word);
        
        // å¦‚æœæ˜¯æ­£ç¡®å›ç­”åå‰è¿›çš„ï¼Œéœ€è¦è°ƒæ•´æ­£ç¡®è®¡æ•°
        if (!isAlreadyInWrong && currentStreak > 0) {
          correctCount--;
          currentStreak--;
        }
        
        currentIndex--;
        saveProgress();
        loadNext();
      }
    }

    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è¾“å…¥æ¡†éƒ½å·²å¡«æ»¡
    function checkAllFilled() {
      const inputs = letterBox.querySelectorAll("input.letter-input");
      for (let input of inputs) {
        if (!input.value) return false;
      }
      return true;
    }

    // è·³è¿‡å½“å‰é¢˜ç›®
    function submitAnswer() {
      if (isReviewMode) {
        // å¤ä¹ æ¨¡å¼ï¼šç›´æ¥è·³è½¬åˆ°ä¸‹ä¸€ä¸ªé”™é¢˜
        currentReviewIndex++;
        loadNext();
        return;
      }
      
      if (inPuzzle) {
        // è°œé¢˜æ¨¡å¼ï¼šç›´æ¥è¿›å…¥ä¸‹ä¸€å…³
        level++;
        levelCorrect = 0;
        currentIndex = level * 8;
        inPuzzle = false;
        saveProgress();
        loadNext();
        return;
      }
      
      // æ­£å¸¸é—¯å…³æ¨¡å¼ï¼šè®°å½•é”™é¢˜å¹¶è·³è½¬
      const currentWords = wordFiles[currentFile].words;
      const currentWord = currentWords[currentIndex];
      // é¿å…é‡å¤æ·»åŠ åŒä¸€é”™é¢˜
      const isAlreadyInWrong = wrongList.some(item => item.word === currentWord.word);
      if (!isAlreadyInWrong) {
        wrongList.push(currentWord);
      }
      
      currentStreak = 0;
      currentIndex++;
      saveProgress();
      loadNext();
    }

    // è®¡ç®—å­—ç¬¦ä¸²ç›¸ä¼¼åº¦ï¼ˆLevenshteinè·ç¦»ç®—æ³•ï¼‰
    function calculateSimilarity(s1, s2) {
      if (s1 === s2) return 1;
      if (s1.length === 0 || s2.length === 0) return 0;
      
      // åˆ›å»ºçŸ©é˜µ
      const matrix = [];
      
      // åˆå§‹åŒ–ç¬¬ä¸€åˆ—
      for (let i = 0; i <= s2.length; i++) {
        matrix[i] = [i];
      }
      
      // åˆå§‹åŒ–ç¬¬ä¸€è¡Œ
      for (let j = 0; j <= s1.length; j++) {
        matrix[0
